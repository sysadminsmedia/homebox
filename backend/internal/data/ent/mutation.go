// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/attachment"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/authroles"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/authtokens"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/entity"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/entityfield"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/entitytype"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/group"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/groupinvitationtoken"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/itemtemplate"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/maintenanceentry"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/notifier"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/predicate"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/tag"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/templatefield"
	"github.com/sysadminsmedia/homebox/backend/internal/data/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment           = "Attachment"
	TypeAuthRoles            = "AuthRoles"
	TypeAuthTokens           = "AuthTokens"
	TypeEntity               = "Entity"
	TypeEntityField          = "EntityField"
	TypeEntityType           = "EntityType"
	TypeGroup                = "Group"
	TypeGroupInvitationToken = "GroupInvitationToken"
	TypeItemTemplate         = "ItemTemplate"
	TypeMaintenanceEntry     = "MaintenanceEntry"
	TypeNotifier             = "Notifier"
	TypeTag                  = "Tag"
	TypeTemplateField        = "TemplateField"
	TypeUser                 = "User"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	_type            *attachment.Type
	primary          *bool
	title            *string
	_path            *string
	mime_type        *string
	clearedFields    map[string]struct{}
	entity           *uuid.UUID
	clearedentity    bool
	thumbnail        *uuid.UUID
	clearedthumbnail bool
	done             bool
	oldValue         func(context.Context) (*Attachment, error)
	predicates       []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *AttachmentMutation) SetType(a attachment.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttachmentMutation) GetType() (r attachment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldType(ctx context.Context) (v attachment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AttachmentMutation) ResetType() {
	m._type = nil
}

// SetPrimary sets the "primary" field.
func (m *AttachmentMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *AttachmentMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *AttachmentMutation) ResetPrimary() {
	m.primary = nil
}

// SetTitle sets the "title" field.
func (m *AttachmentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AttachmentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AttachmentMutation) ResetTitle() {
	m.title = nil
}

// SetPath sets the "path" field.
func (m *AttachmentMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AttachmentMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AttachmentMutation) ResetPath() {
	m._path = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AttachmentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AttachmentMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *AttachmentMutation) SetEntityID(id uuid.UUID) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *AttachmentMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *AttachmentMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *AttachmentMutation) EntityID() (id uuid.UUID, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) EntityIDs() (ids []uuid.UUID) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *AttachmentMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// SetThumbnailID sets the "thumbnail" edge to the Attachment entity by id.
func (m *AttachmentMutation) SetThumbnailID(id uuid.UUID) {
	m.thumbnail = &id
}

// ClearThumbnail clears the "thumbnail" edge to the Attachment entity.
func (m *AttachmentMutation) ClearThumbnail() {
	m.clearedthumbnail = true
}

// ThumbnailCleared reports if the "thumbnail" edge to the Attachment entity was cleared.
func (m *AttachmentMutation) ThumbnailCleared() bool {
	return m.clearedthumbnail
}

// ThumbnailID returns the "thumbnail" edge ID in the mutation.
func (m *AttachmentMutation) ThumbnailID() (id uuid.UUID, exists bool) {
	if m.thumbnail != nil {
		return *m.thumbnail, true
	}
	return
}

// ThumbnailIDs returns the "thumbnail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThumbnailID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) ThumbnailIDs() (ids []uuid.UUID) {
	if id := m.thumbnail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThumbnail resets all changes to the "thumbnail" edge.
func (m *AttachmentMutation) ResetThumbnail() {
	m.thumbnail = nil
	m.clearedthumbnail = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, attachment.FieldType)
	}
	if m.primary != nil {
		fields = append(fields, attachment.FieldPrimary)
	}
	if m.title != nil {
		fields = append(fields, attachment.FieldTitle)
	}
	if m._path != nil {
		fields = append(fields, attachment.FieldPath)
	}
	if m.mime_type != nil {
		fields = append(fields, attachment.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldType:
		return m.GetType()
	case attachment.FieldPrimary:
		return m.Primary()
	case attachment.FieldTitle:
		return m.Title()
	case attachment.FieldPath:
		return m.Path()
	case attachment.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldType:
		return m.OldType(ctx)
	case attachment.FieldPrimary:
		return m.OldPrimary(ctx)
	case attachment.FieldTitle:
		return m.OldTitle(ctx)
	case attachment.FieldPath:
		return m.OldPath(ctx)
	case attachment.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldType:
		v, ok := value.(attachment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attachment.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case attachment.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case attachment.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case attachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldType:
		m.ResetType()
		return nil
	case attachment.FieldPrimary:
		m.ResetPrimary()
		return nil
	case attachment.FieldTitle:
		m.ResetTitle()
		return nil
	case attachment.FieldPath:
		m.ResetPath()
		return nil
	case attachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entity != nil {
		edges = append(edges, attachment.EdgeEntity)
	}
	if m.thumbnail != nil {
		edges = append(edges, attachment.EdgeThumbnail)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeThumbnail:
		if id := m.thumbnail; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentity {
		edges = append(edges, attachment.EdgeEntity)
	}
	if m.clearedthumbnail {
		edges = append(edges, attachment.EdgeThumbnail)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeEntity:
		return m.clearedentity
	case attachment.EdgeThumbnail:
		return m.clearedthumbnail
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeEntity:
		m.ClearEntity()
		return nil
	case attachment.EdgeThumbnail:
		m.ClearThumbnail()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeEntity:
		m.ResetEntity()
		return nil
	case attachment.EdgeThumbnail:
		m.ResetThumbnail()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuthRolesMutation represents an operation that mutates the AuthRoles nodes in the graph.
type AuthRolesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role          *authroles.Role
	clearedFields map[string]struct{}
	token         *uuid.UUID
	clearedtoken  bool
	done          bool
	oldValue      func(context.Context) (*AuthRoles, error)
	predicates    []predicate.AuthRoles
}

var _ ent.Mutation = (*AuthRolesMutation)(nil)

// authrolesOption allows management of the mutation configuration using functional options.
type authrolesOption func(*AuthRolesMutation)

// newAuthRolesMutation creates new mutation for the AuthRoles entity.
func newAuthRolesMutation(c config, op Op, opts ...authrolesOption) *AuthRolesMutation {
	m := &AuthRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRolesID sets the ID field of the mutation.
func withAuthRolesID(id int) authrolesOption {
	return func(m *AuthRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRoles
		)
		m.oldValue = func(ctx context.Context) (*AuthRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRoles sets the old AuthRoles of the mutation.
func withAuthRoles(node *AuthRoles) authrolesOption {
	return func(m *AuthRolesMutation) {
		m.oldValue = func(context.Context) (*AuthRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRolesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRolesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *AuthRolesMutation) SetRole(a authroles.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AuthRolesMutation) Role() (r authroles.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AuthRoles entity.
// If the AuthRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRolesMutation) OldRole(ctx context.Context) (v authroles.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AuthRolesMutation) ResetRole() {
	m.role = nil
}

// SetTokenID sets the "token" edge to the AuthTokens entity by id.
func (m *AuthRolesMutation) SetTokenID(id uuid.UUID) {
	m.token = &id
}

// ClearToken clears the "token" edge to the AuthTokens entity.
func (m *AuthRolesMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the AuthTokens entity was cleared.
func (m *AuthRolesMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the "token" edge ID in the mutation.
func (m *AuthRolesMutation) TokenID() (id uuid.UUID, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *AuthRolesMutation) TokenIDs() (ids []uuid.UUID) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *AuthRolesMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// Where appends a list predicates to the AuthRolesMutation builder.
func (m *AuthRolesMutation) Where(ps ...predicate.AuthRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthRoles).
func (m *AuthRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRolesMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, authroles.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authroles.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authroles.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authroles.FieldRole:
		v, ok := value.(authroles.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRolesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRolesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRolesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRolesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRolesMutation) ResetField(name string) error {
	switch name {
	case authroles.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token != nil {
		edges = append(edges, authroles.EdgeToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRolesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authroles.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken {
		edges = append(edges, authroles.EdgeToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRolesMutation) EdgeCleared(name string) bool {
	switch name {
	case authroles.EdgeToken:
		return m.clearedtoken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRolesMutation) ClearEdge(name string) error {
	switch name {
	case authroles.EdgeToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRolesMutation) ResetEdge(name string) error {
	switch name {
	case authroles.EdgeToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown AuthRoles edge %s", name)
}

// AuthTokensMutation represents an operation that mutates the AuthTokens nodes in the graph.
type AuthTokensMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	token         *[]byte
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	roles         *int
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*AuthTokens, error)
	predicates    []predicate.AuthTokens
}

var _ ent.Mutation = (*AuthTokensMutation)(nil)

// authtokensOption allows management of the mutation configuration using functional options.
type authtokensOption func(*AuthTokensMutation)

// newAuthTokensMutation creates new mutation for the AuthTokens entity.
func newAuthTokensMutation(c config, op Op, opts ...authtokensOption) *AuthTokensMutation {
	m := &AuthTokensMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthTokens,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokensID sets the ID field of the mutation.
func withAuthTokensID(id uuid.UUID) authtokensOption {
	return func(m *AuthTokensMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthTokens
		)
		m.oldValue = func(ctx context.Context) (*AuthTokens, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthTokens.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthTokens sets the old AuthTokens of the mutation.
func withAuthTokens(node *AuthTokens) authtokensOption {
	return func(m *AuthTokensMutation) {
		m.oldValue = func(context.Context) (*AuthTokens, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokensMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokensMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthTokens entities.
func (m *AuthTokensMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokensMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokensMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthTokens.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTokensMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTokensMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTokensMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthTokensMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthTokensMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthTokensMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *AuthTokensMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthTokensMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthTokensMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthTokensMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthTokensMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthTokens entity.
// If the AuthTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokensMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthTokensMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuthTokensMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthTokensMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthTokensMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuthTokensMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthTokensMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthTokensMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRolesID sets the "roles" edge to the AuthRoles entity by id.
func (m *AuthTokensMutation) SetRolesID(id int) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the AuthRoles entity.
func (m *AuthTokensMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AuthRoles entity was cleared.
func (m *AuthTokensMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *AuthTokensMutation) RolesID() (id int, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *AuthTokensMutation) RolesIDs() (ids []int) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AuthTokensMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// Where appends a list predicates to the AuthTokensMutation builder.
func (m *AuthTokensMutation) Where(ps ...predicate.AuthTokens) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokensMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokensMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthTokens, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokensMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokensMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthTokens).
func (m *AuthTokensMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokensMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, authtokens.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authtokens.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, authtokens.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, authtokens.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokensMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.CreatedAt()
	case authtokens.FieldUpdatedAt:
		return m.UpdatedAt()
	case authtokens.FieldToken:
		return m.Token()
	case authtokens.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokensMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtokens.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authtokens.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authtokens.FieldToken:
		return m.OldToken(ctx)
	case authtokens.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthTokens field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtokens.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authtokens.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authtokens.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authtokens.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokensMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokensMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokensMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthTokens numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokensMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokensMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokensMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthTokens nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokensMutation) ResetField(name string) error {
	switch name {
	case authtokens.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authtokens.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authtokens.FieldToken:
		m.ResetToken()
		return nil
	case authtokens.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokensMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, authtokens.EdgeUser)
	}
	if m.roles != nil {
		edges = append(edges, authtokens.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokensMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtokens.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case authtokens.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokensMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokensMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokensMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, authtokens.EdgeUser)
	}
	if m.clearedroles {
		edges = append(edges, authtokens.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokensMutation) EdgeCleared(name string) bool {
	switch name {
	case authtokens.EdgeUser:
		return m.cleareduser
	case authtokens.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokensMutation) ClearEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ClearUser()
		return nil
	case authtokens.EdgeRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokensMutation) ResetEdge(name string) error {
	switch name {
	case authtokens.EdgeUser:
		m.ResetUser()
		return nil
	case authtokens.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown AuthTokens edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	name                          *string
	description                   *string
	import_ref                    *string
	notes                         *string
	quantity                      *int
	addquantity                   *int
	insured                       *bool
	archived                      *bool
	asset_id                      *int
	addasset_id                   *int
	sync_child_entities_locations *bool
	serial_number                 *string
	model_number                  *string
	manufacturer                  *string
	lifetime_warranty             *bool
	warranty_expires              *time.Time
	warranty_details              *string
	purchase_time                 *time.Time
	purchase_from                 *string
	purchase_price                *float64
	addpurchase_price             *float64
	sold_time                     *time.Time
	sold_to                       *string
	sold_price                    *float64
	addsold_price                 *float64
	sold_notes                    *string
	clearedFields                 map[string]struct{}
	group                         *uuid.UUID
	clearedgroup                  bool
	children                      map[uuid.UUID]struct{}
	removedchildren               map[uuid.UUID]struct{}
	clearedchildren               bool
	parent                        *uuid.UUID
	clearedparent                 bool
	entity                        map[uuid.UUID]struct{}
	removedentity                 map[uuid.UUID]struct{}
	clearedentity                 bool
	location                      *uuid.UUID
	clearedlocation               bool
	tag                           map[uuid.UUID]struct{}
	removedtag                    map[uuid.UUID]struct{}
	clearedtag                    bool
	_type                         *uuid.UUID
	cleared_type                  bool
	fields                        map[uuid.UUID]struct{}
	removedfields                 map[uuid.UUID]struct{}
	clearedfields                 bool
	maintenance_entries           map[uuid.UUID]struct{}
	removedmaintenance_entries    map[uuid.UUID]struct{}
	clearedmaintenance_entries    bool
	attachments                   map[uuid.UUID]struct{}
	removedattachments            map[uuid.UUID]struct{}
	clearedattachments            bool
	done                          bool
	oldValue                      func(context.Context) (*Entity, error)
	predicates                    []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id uuid.UUID) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entity entities.
func (m *EntityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EntityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entity.FieldDescription)
}

// SetImportRef sets the "import_ref" field.
func (m *EntityMutation) SetImportRef(s string) {
	m.import_ref = &s
}

// ImportRef returns the value of the "import_ref" field in the mutation.
func (m *EntityMutation) ImportRef() (r string, exists bool) {
	v := m.import_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldImportRef returns the old "import_ref" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldImportRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportRef: %w", err)
	}
	return oldValue.ImportRef, nil
}

// ClearImportRef clears the value of the "import_ref" field.
func (m *EntityMutation) ClearImportRef() {
	m.import_ref = nil
	m.clearedFields[entity.FieldImportRef] = struct{}{}
}

// ImportRefCleared returns if the "import_ref" field was cleared in this mutation.
func (m *EntityMutation) ImportRefCleared() bool {
	_, ok := m.clearedFields[entity.FieldImportRef]
	return ok
}

// ResetImportRef resets all changes to the "import_ref" field.
func (m *EntityMutation) ResetImportRef() {
	m.import_ref = nil
	delete(m.clearedFields, entity.FieldImportRef)
}

// SetNotes sets the "notes" field.
func (m *EntityMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *EntityMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *EntityMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[entity.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *EntityMutation) NotesCleared() bool {
	_, ok := m.clearedFields[entity.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *EntityMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, entity.FieldNotes)
}

// SetQuantity sets the "quantity" field.
func (m *EntityMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *EntityMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *EntityMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *EntityMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *EntityMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetInsured sets the "insured" field.
func (m *EntityMutation) SetInsured(b bool) {
	m.insured = &b
}

// Insured returns the value of the "insured" field in the mutation.
func (m *EntityMutation) Insured() (r bool, exists bool) {
	v := m.insured
	if v == nil {
		return
	}
	return *v, true
}

// OldInsured returns the old "insured" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldInsured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsured: %w", err)
	}
	return oldValue.Insured, nil
}

// ResetInsured resets all changes to the "insured" field.
func (m *EntityMutation) ResetInsured() {
	m.insured = nil
}

// SetArchived sets the "archived" field.
func (m *EntityMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *EntityMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *EntityMutation) ResetArchived() {
	m.archived = nil
}

// SetAssetID sets the "asset_id" field.
func (m *EntityMutation) SetAssetID(i int) {
	m.asset_id = &i
	m.addasset_id = nil
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *EntityMutation) AssetID() (r int, exists bool) {
	v := m.asset_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldAssetID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// AddAssetID adds i to the "asset_id" field.
func (m *EntityMutation) AddAssetID(i int) {
	if m.addasset_id != nil {
		*m.addasset_id += i
	} else {
		m.addasset_id = &i
	}
}

// AddedAssetID returns the value that was added to the "asset_id" field in this mutation.
func (m *EntityMutation) AddedAssetID() (r int, exists bool) {
	v := m.addasset_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *EntityMutation) ResetAssetID() {
	m.asset_id = nil
	m.addasset_id = nil
}

// SetSyncChildEntitiesLocations sets the "sync_child_entities_locations" field.
func (m *EntityMutation) SetSyncChildEntitiesLocations(b bool) {
	m.sync_child_entities_locations = &b
}

// SyncChildEntitiesLocations returns the value of the "sync_child_entities_locations" field in the mutation.
func (m *EntityMutation) SyncChildEntitiesLocations() (r bool, exists bool) {
	v := m.sync_child_entities_locations
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncChildEntitiesLocations returns the old "sync_child_entities_locations" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSyncChildEntitiesLocations(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncChildEntitiesLocations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncChildEntitiesLocations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncChildEntitiesLocations: %w", err)
	}
	return oldValue.SyncChildEntitiesLocations, nil
}

// ResetSyncChildEntitiesLocations resets all changes to the "sync_child_entities_locations" field.
func (m *EntityMutation) ResetSyncChildEntitiesLocations() {
	m.sync_child_entities_locations = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *EntityMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *EntityMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *EntityMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[entity.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *EntityMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[entity.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *EntityMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, entity.FieldSerialNumber)
}

// SetModelNumber sets the "model_number" field.
func (m *EntityMutation) SetModelNumber(s string) {
	m.model_number = &s
}

// ModelNumber returns the value of the "model_number" field in the mutation.
func (m *EntityMutation) ModelNumber() (r string, exists bool) {
	v := m.model_number
	if v == nil {
		return
	}
	return *v, true
}

// OldModelNumber returns the old "model_number" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldModelNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelNumber: %w", err)
	}
	return oldValue.ModelNumber, nil
}

// ClearModelNumber clears the value of the "model_number" field.
func (m *EntityMutation) ClearModelNumber() {
	m.model_number = nil
	m.clearedFields[entity.FieldModelNumber] = struct{}{}
}

// ModelNumberCleared returns if the "model_number" field was cleared in this mutation.
func (m *EntityMutation) ModelNumberCleared() bool {
	_, ok := m.clearedFields[entity.FieldModelNumber]
	return ok
}

// ResetModelNumber resets all changes to the "model_number" field.
func (m *EntityMutation) ResetModelNumber() {
	m.model_number = nil
	delete(m.clearedFields, entity.FieldModelNumber)
}

// SetManufacturer sets the "manufacturer" field.
func (m *EntityMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *EntityMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *EntityMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[entity.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *EntityMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[entity.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *EntityMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, entity.FieldManufacturer)
}

// SetLifetimeWarranty sets the "lifetime_warranty" field.
func (m *EntityMutation) SetLifetimeWarranty(b bool) {
	m.lifetime_warranty = &b
}

// LifetimeWarranty returns the value of the "lifetime_warranty" field in the mutation.
func (m *EntityMutation) LifetimeWarranty() (r bool, exists bool) {
	v := m.lifetime_warranty
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeWarranty returns the old "lifetime_warranty" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldLifetimeWarranty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeWarranty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeWarranty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeWarranty: %w", err)
	}
	return oldValue.LifetimeWarranty, nil
}

// ResetLifetimeWarranty resets all changes to the "lifetime_warranty" field.
func (m *EntityMutation) ResetLifetimeWarranty() {
	m.lifetime_warranty = nil
}

// SetWarrantyExpires sets the "warranty_expires" field.
func (m *EntityMutation) SetWarrantyExpires(t time.Time) {
	m.warranty_expires = &t
}

// WarrantyExpires returns the value of the "warranty_expires" field in the mutation.
func (m *EntityMutation) WarrantyExpires() (r time.Time, exists bool) {
	v := m.warranty_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyExpires returns the old "warranty_expires" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldWarrantyExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyExpires: %w", err)
	}
	return oldValue.WarrantyExpires, nil
}

// ClearWarrantyExpires clears the value of the "warranty_expires" field.
func (m *EntityMutation) ClearWarrantyExpires() {
	m.warranty_expires = nil
	m.clearedFields[entity.FieldWarrantyExpires] = struct{}{}
}

// WarrantyExpiresCleared returns if the "warranty_expires" field was cleared in this mutation.
func (m *EntityMutation) WarrantyExpiresCleared() bool {
	_, ok := m.clearedFields[entity.FieldWarrantyExpires]
	return ok
}

// ResetWarrantyExpires resets all changes to the "warranty_expires" field.
func (m *EntityMutation) ResetWarrantyExpires() {
	m.warranty_expires = nil
	delete(m.clearedFields, entity.FieldWarrantyExpires)
}

// SetWarrantyDetails sets the "warranty_details" field.
func (m *EntityMutation) SetWarrantyDetails(s string) {
	m.warranty_details = &s
}

// WarrantyDetails returns the value of the "warranty_details" field in the mutation.
func (m *EntityMutation) WarrantyDetails() (r string, exists bool) {
	v := m.warranty_details
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyDetails returns the old "warranty_details" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldWarrantyDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyDetails: %w", err)
	}
	return oldValue.WarrantyDetails, nil
}

// ClearWarrantyDetails clears the value of the "warranty_details" field.
func (m *EntityMutation) ClearWarrantyDetails() {
	m.warranty_details = nil
	m.clearedFields[entity.FieldWarrantyDetails] = struct{}{}
}

// WarrantyDetailsCleared returns if the "warranty_details" field was cleared in this mutation.
func (m *EntityMutation) WarrantyDetailsCleared() bool {
	_, ok := m.clearedFields[entity.FieldWarrantyDetails]
	return ok
}

// ResetWarrantyDetails resets all changes to the "warranty_details" field.
func (m *EntityMutation) ResetWarrantyDetails() {
	m.warranty_details = nil
	delete(m.clearedFields, entity.FieldWarrantyDetails)
}

// SetPurchaseTime sets the "purchase_time" field.
func (m *EntityMutation) SetPurchaseTime(t time.Time) {
	m.purchase_time = &t
}

// PurchaseTime returns the value of the "purchase_time" field in the mutation.
func (m *EntityMutation) PurchaseTime() (r time.Time, exists bool) {
	v := m.purchase_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseTime returns the old "purchase_time" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldPurchaseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseTime: %w", err)
	}
	return oldValue.PurchaseTime, nil
}

// ClearPurchaseTime clears the value of the "purchase_time" field.
func (m *EntityMutation) ClearPurchaseTime() {
	m.purchase_time = nil
	m.clearedFields[entity.FieldPurchaseTime] = struct{}{}
}

// PurchaseTimeCleared returns if the "purchase_time" field was cleared in this mutation.
func (m *EntityMutation) PurchaseTimeCleared() bool {
	_, ok := m.clearedFields[entity.FieldPurchaseTime]
	return ok
}

// ResetPurchaseTime resets all changes to the "purchase_time" field.
func (m *EntityMutation) ResetPurchaseTime() {
	m.purchase_time = nil
	delete(m.clearedFields, entity.FieldPurchaseTime)
}

// SetPurchaseFrom sets the "purchase_from" field.
func (m *EntityMutation) SetPurchaseFrom(s string) {
	m.purchase_from = &s
}

// PurchaseFrom returns the value of the "purchase_from" field in the mutation.
func (m *EntityMutation) PurchaseFrom() (r string, exists bool) {
	v := m.purchase_from
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseFrom returns the old "purchase_from" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldPurchaseFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseFrom: %w", err)
	}
	return oldValue.PurchaseFrom, nil
}

// ClearPurchaseFrom clears the value of the "purchase_from" field.
func (m *EntityMutation) ClearPurchaseFrom() {
	m.purchase_from = nil
	m.clearedFields[entity.FieldPurchaseFrom] = struct{}{}
}

// PurchaseFromCleared returns if the "purchase_from" field was cleared in this mutation.
func (m *EntityMutation) PurchaseFromCleared() bool {
	_, ok := m.clearedFields[entity.FieldPurchaseFrom]
	return ok
}

// ResetPurchaseFrom resets all changes to the "purchase_from" field.
func (m *EntityMutation) ResetPurchaseFrom() {
	m.purchase_from = nil
	delete(m.clearedFields, entity.FieldPurchaseFrom)
}

// SetPurchasePrice sets the "purchase_price" field.
func (m *EntityMutation) SetPurchasePrice(f float64) {
	m.purchase_price = &f
	m.addpurchase_price = nil
}

// PurchasePrice returns the value of the "purchase_price" field in the mutation.
func (m *EntityMutation) PurchasePrice() (r float64, exists bool) {
	v := m.purchase_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasePrice returns the old "purchase_price" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldPurchasePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasePrice: %w", err)
	}
	return oldValue.PurchasePrice, nil
}

// AddPurchasePrice adds f to the "purchase_price" field.
func (m *EntityMutation) AddPurchasePrice(f float64) {
	if m.addpurchase_price != nil {
		*m.addpurchase_price += f
	} else {
		m.addpurchase_price = &f
	}
}

// AddedPurchasePrice returns the value that was added to the "purchase_price" field in this mutation.
func (m *EntityMutation) AddedPurchasePrice() (r float64, exists bool) {
	v := m.addpurchase_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchasePrice resets all changes to the "purchase_price" field.
func (m *EntityMutation) ResetPurchasePrice() {
	m.purchase_price = nil
	m.addpurchase_price = nil
}

// SetSoldTime sets the "sold_time" field.
func (m *EntityMutation) SetSoldTime(t time.Time) {
	m.sold_time = &t
}

// SoldTime returns the value of the "sold_time" field in the mutation.
func (m *EntityMutation) SoldTime() (r time.Time, exists bool) {
	v := m.sold_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTime returns the old "sold_time" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSoldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTime: %w", err)
	}
	return oldValue.SoldTime, nil
}

// ClearSoldTime clears the value of the "sold_time" field.
func (m *EntityMutation) ClearSoldTime() {
	m.sold_time = nil
	m.clearedFields[entity.FieldSoldTime] = struct{}{}
}

// SoldTimeCleared returns if the "sold_time" field was cleared in this mutation.
func (m *EntityMutation) SoldTimeCleared() bool {
	_, ok := m.clearedFields[entity.FieldSoldTime]
	return ok
}

// ResetSoldTime resets all changes to the "sold_time" field.
func (m *EntityMutation) ResetSoldTime() {
	m.sold_time = nil
	delete(m.clearedFields, entity.FieldSoldTime)
}

// SetSoldTo sets the "sold_to" field.
func (m *EntityMutation) SetSoldTo(s string) {
	m.sold_to = &s
}

// SoldTo returns the value of the "sold_to" field in the mutation.
func (m *EntityMutation) SoldTo() (r string, exists bool) {
	v := m.sold_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldTo returns the old "sold_to" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSoldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldTo: %w", err)
	}
	return oldValue.SoldTo, nil
}

// ClearSoldTo clears the value of the "sold_to" field.
func (m *EntityMutation) ClearSoldTo() {
	m.sold_to = nil
	m.clearedFields[entity.FieldSoldTo] = struct{}{}
}

// SoldToCleared returns if the "sold_to" field was cleared in this mutation.
func (m *EntityMutation) SoldToCleared() bool {
	_, ok := m.clearedFields[entity.FieldSoldTo]
	return ok
}

// ResetSoldTo resets all changes to the "sold_to" field.
func (m *EntityMutation) ResetSoldTo() {
	m.sold_to = nil
	delete(m.clearedFields, entity.FieldSoldTo)
}

// SetSoldPrice sets the "sold_price" field.
func (m *EntityMutation) SetSoldPrice(f float64) {
	m.sold_price = &f
	m.addsold_price = nil
}

// SoldPrice returns the value of the "sold_price" field in the mutation.
func (m *EntityMutation) SoldPrice() (r float64, exists bool) {
	v := m.sold_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldPrice returns the old "sold_price" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSoldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldPrice: %w", err)
	}
	return oldValue.SoldPrice, nil
}

// AddSoldPrice adds f to the "sold_price" field.
func (m *EntityMutation) AddSoldPrice(f float64) {
	if m.addsold_price != nil {
		*m.addsold_price += f
	} else {
		m.addsold_price = &f
	}
}

// AddedSoldPrice returns the value that was added to the "sold_price" field in this mutation.
func (m *EntityMutation) AddedSoldPrice() (r float64, exists bool) {
	v := m.addsold_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoldPrice resets all changes to the "sold_price" field.
func (m *EntityMutation) ResetSoldPrice() {
	m.sold_price = nil
	m.addsold_price = nil
}

// SetSoldNotes sets the "sold_notes" field.
func (m *EntityMutation) SetSoldNotes(s string) {
	m.sold_notes = &s
}

// SoldNotes returns the value of the "sold_notes" field in the mutation.
func (m *EntityMutation) SoldNotes() (r string, exists bool) {
	v := m.sold_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldNotes returns the old "sold_notes" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldSoldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldNotes: %w", err)
	}
	return oldValue.SoldNotes, nil
}

// ClearSoldNotes clears the value of the "sold_notes" field.
func (m *EntityMutation) ClearSoldNotes() {
	m.sold_notes = nil
	m.clearedFields[entity.FieldSoldNotes] = struct{}{}
}

// SoldNotesCleared returns if the "sold_notes" field was cleared in this mutation.
func (m *EntityMutation) SoldNotesCleared() bool {
	_, ok := m.clearedFields[entity.FieldSoldNotes]
	return ok
}

// ResetSoldNotes resets all changes to the "sold_notes" field.
func (m *EntityMutation) ResetSoldNotes() {
	m.sold_notes = nil
	delete(m.clearedFields, entity.FieldSoldNotes)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *EntityMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *EntityMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *EntityMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *EntityMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *EntityMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddChildIDs adds the "children" edge to the Entity entity by ids.
func (m *EntityMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Entity entity.
func (m *EntityMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Entity entity was cleared.
func (m *EntityMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Entity entity by IDs.
func (m *EntityMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Entity entity.
func (m *EntityMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *EntityMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *EntityMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the Entity entity by id.
func (m *EntityMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Entity entity.
func (m *EntityMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Entity entity was cleared.
func (m *EntityMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *EntityMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *EntityMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEntityIDs adds the "entity" edge to the Entity entity by ids.
func (m *EntityMutation) AddEntityIDs(ids ...uuid.UUID) {
	if m.entity == nil {
		m.entity = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entity[ids[i]] = struct{}{}
	}
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *EntityMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *EntityMutation) EntityCleared() bool {
	return m.clearedentity
}

// RemoveEntityIDs removes the "entity" edge to the Entity entity by IDs.
func (m *EntityMutation) RemoveEntityIDs(ids ...uuid.UUID) {
	if m.removedentity == nil {
		m.removedentity = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entity, ids[i])
		m.removedentity[ids[i]] = struct{}{}
	}
}

// RemovedEntity returns the removed IDs of the "entity" edge to the Entity entity.
func (m *EntityMutation) RemovedEntityIDs() (ids []uuid.UUID) {
	for id := range m.removedentity {
		ids = append(ids, id)
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
func (m *EntityMutation) EntityIDs() (ids []uuid.UUID) {
	for id := range m.entity {
		ids = append(ids, id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *EntityMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
	m.removedentity = nil
}

// SetLocationID sets the "location" edge to the Entity entity by id.
func (m *EntityMutation) SetLocationID(id uuid.UUID) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Entity entity.
func (m *EntityMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Entity entity was cleared.
func (m *EntityMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *EntityMutation) LocationID() (id uuid.UUID, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *EntityMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *EntityMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tag == nil {
		m.tag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *EntityMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *EntityMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *EntityMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtag == nil {
		m.removedtag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *EntityMutation) RemovedTagIDs() (ids []uuid.UUID) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *EntityMutation) TagIDs() (ids []uuid.UUID) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *EntityMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// SetTypeID sets the "type" edge to the EntityType entity by id.
func (m *EntityMutation) SetTypeID(id uuid.UUID) {
	m._type = &id
}

// ClearType clears the "type" edge to the EntityType entity.
func (m *EntityMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the EntityType entity was cleared.
func (m *EntityMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *EntityMutation) TypeID() (id uuid.UUID, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) TypeIDs() (ids []uuid.UUID) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *EntityMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// AddFieldIDs adds the "fields" edge to the EntityField entity by ids.
func (m *EntityMutation) AddFieldIDs(ids ...uuid.UUID) {
	if m.fields == nil {
		m.fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the EntityField entity.
func (m *EntityMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the EntityField entity was cleared.
func (m *EntityMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the EntityField entity by IDs.
func (m *EntityMutation) RemoveFieldIDs(ids ...uuid.UUID) {
	if m.removedfields == nil {
		m.removedfields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the EntityField entity.
func (m *EntityMutation) RemovedFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *EntityMutation) FieldsIDs() (ids []uuid.UUID) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *EntityMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// AddMaintenanceEntryIDs adds the "maintenance_entries" edge to the MaintenanceEntry entity by ids.
func (m *EntityMutation) AddMaintenanceEntryIDs(ids ...uuid.UUID) {
	if m.maintenance_entries == nil {
		m.maintenance_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.maintenance_entries[ids[i]] = struct{}{}
	}
}

// ClearMaintenanceEntries clears the "maintenance_entries" edge to the MaintenanceEntry entity.
func (m *EntityMutation) ClearMaintenanceEntries() {
	m.clearedmaintenance_entries = true
}

// MaintenanceEntriesCleared reports if the "maintenance_entries" edge to the MaintenanceEntry entity was cleared.
func (m *EntityMutation) MaintenanceEntriesCleared() bool {
	return m.clearedmaintenance_entries
}

// RemoveMaintenanceEntryIDs removes the "maintenance_entries" edge to the MaintenanceEntry entity by IDs.
func (m *EntityMutation) RemoveMaintenanceEntryIDs(ids ...uuid.UUID) {
	if m.removedmaintenance_entries == nil {
		m.removedmaintenance_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.maintenance_entries, ids[i])
		m.removedmaintenance_entries[ids[i]] = struct{}{}
	}
}

// RemovedMaintenanceEntries returns the removed IDs of the "maintenance_entries" edge to the MaintenanceEntry entity.
func (m *EntityMutation) RemovedMaintenanceEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedmaintenance_entries {
		ids = append(ids, id)
	}
	return
}

// MaintenanceEntriesIDs returns the "maintenance_entries" edge IDs in the mutation.
func (m *EntityMutation) MaintenanceEntriesIDs() (ids []uuid.UUID) {
	for id := range m.maintenance_entries {
		ids = append(ids, id)
	}
	return
}

// ResetMaintenanceEntries resets all changes to the "maintenance_entries" edge.
func (m *EntityMutation) ResetMaintenanceEntries() {
	m.maintenance_entries = nil
	m.clearedmaintenance_entries = false
	m.removedmaintenance_entries = nil
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *EntityMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *EntityMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *EntityMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *EntityMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *EntityMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *EntityMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *EntityMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, entity.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entity.FieldDescription)
	}
	if m.import_ref != nil {
		fields = append(fields, entity.FieldImportRef)
	}
	if m.notes != nil {
		fields = append(fields, entity.FieldNotes)
	}
	if m.quantity != nil {
		fields = append(fields, entity.FieldQuantity)
	}
	if m.insured != nil {
		fields = append(fields, entity.FieldInsured)
	}
	if m.archived != nil {
		fields = append(fields, entity.FieldArchived)
	}
	if m.asset_id != nil {
		fields = append(fields, entity.FieldAssetID)
	}
	if m.sync_child_entities_locations != nil {
		fields = append(fields, entity.FieldSyncChildEntitiesLocations)
	}
	if m.serial_number != nil {
		fields = append(fields, entity.FieldSerialNumber)
	}
	if m.model_number != nil {
		fields = append(fields, entity.FieldModelNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, entity.FieldManufacturer)
	}
	if m.lifetime_warranty != nil {
		fields = append(fields, entity.FieldLifetimeWarranty)
	}
	if m.warranty_expires != nil {
		fields = append(fields, entity.FieldWarrantyExpires)
	}
	if m.warranty_details != nil {
		fields = append(fields, entity.FieldWarrantyDetails)
	}
	if m.purchase_time != nil {
		fields = append(fields, entity.FieldPurchaseTime)
	}
	if m.purchase_from != nil {
		fields = append(fields, entity.FieldPurchaseFrom)
	}
	if m.purchase_price != nil {
		fields = append(fields, entity.FieldPurchasePrice)
	}
	if m.sold_time != nil {
		fields = append(fields, entity.FieldSoldTime)
	}
	if m.sold_to != nil {
		fields = append(fields, entity.FieldSoldTo)
	}
	if m.sold_price != nil {
		fields = append(fields, entity.FieldSoldPrice)
	}
	if m.sold_notes != nil {
		fields = append(fields, entity.FieldSoldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldName:
		return m.Name()
	case entity.FieldDescription:
		return m.Description()
	case entity.FieldImportRef:
		return m.ImportRef()
	case entity.FieldNotes:
		return m.Notes()
	case entity.FieldQuantity:
		return m.Quantity()
	case entity.FieldInsured:
		return m.Insured()
	case entity.FieldArchived:
		return m.Archived()
	case entity.FieldAssetID:
		return m.AssetID()
	case entity.FieldSyncChildEntitiesLocations:
		return m.SyncChildEntitiesLocations()
	case entity.FieldSerialNumber:
		return m.SerialNumber()
	case entity.FieldModelNumber:
		return m.ModelNumber()
	case entity.FieldManufacturer:
		return m.Manufacturer()
	case entity.FieldLifetimeWarranty:
		return m.LifetimeWarranty()
	case entity.FieldWarrantyExpires:
		return m.WarrantyExpires()
	case entity.FieldWarrantyDetails:
		return m.WarrantyDetails()
	case entity.FieldPurchaseTime:
		return m.PurchaseTime()
	case entity.FieldPurchaseFrom:
		return m.PurchaseFrom()
	case entity.FieldPurchasePrice:
		return m.PurchasePrice()
	case entity.FieldSoldTime:
		return m.SoldTime()
	case entity.FieldSoldTo:
		return m.SoldTo()
	case entity.FieldSoldPrice:
		return m.SoldPrice()
	case entity.FieldSoldNotes:
		return m.SoldNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldName:
		return m.OldName(ctx)
	case entity.FieldDescription:
		return m.OldDescription(ctx)
	case entity.FieldImportRef:
		return m.OldImportRef(ctx)
	case entity.FieldNotes:
		return m.OldNotes(ctx)
	case entity.FieldQuantity:
		return m.OldQuantity(ctx)
	case entity.FieldInsured:
		return m.OldInsured(ctx)
	case entity.FieldArchived:
		return m.OldArchived(ctx)
	case entity.FieldAssetID:
		return m.OldAssetID(ctx)
	case entity.FieldSyncChildEntitiesLocations:
		return m.OldSyncChildEntitiesLocations(ctx)
	case entity.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case entity.FieldModelNumber:
		return m.OldModelNumber(ctx)
	case entity.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case entity.FieldLifetimeWarranty:
		return m.OldLifetimeWarranty(ctx)
	case entity.FieldWarrantyExpires:
		return m.OldWarrantyExpires(ctx)
	case entity.FieldWarrantyDetails:
		return m.OldWarrantyDetails(ctx)
	case entity.FieldPurchaseTime:
		return m.OldPurchaseTime(ctx)
	case entity.FieldPurchaseFrom:
		return m.OldPurchaseFrom(ctx)
	case entity.FieldPurchasePrice:
		return m.OldPurchasePrice(ctx)
	case entity.FieldSoldTime:
		return m.OldSoldTime(ctx)
	case entity.FieldSoldTo:
		return m.OldSoldTo(ctx)
	case entity.FieldSoldPrice:
		return m.OldSoldPrice(ctx)
	case entity.FieldSoldNotes:
		return m.OldSoldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entity.FieldImportRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportRef(v)
		return nil
	case entity.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case entity.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case entity.FieldInsured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsured(v)
		return nil
	case entity.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case entity.FieldAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	case entity.FieldSyncChildEntitiesLocations:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncChildEntitiesLocations(v)
		return nil
	case entity.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case entity.FieldModelNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelNumber(v)
		return nil
	case entity.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case entity.FieldLifetimeWarranty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeWarranty(v)
		return nil
	case entity.FieldWarrantyExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyExpires(v)
		return nil
	case entity.FieldWarrantyDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyDetails(v)
		return nil
	case entity.FieldPurchaseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseTime(v)
		return nil
	case entity.FieldPurchaseFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseFrom(v)
		return nil
	case entity.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasePrice(v)
		return nil
	case entity.FieldSoldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTime(v)
		return nil
	case entity.FieldSoldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldTo(v)
		return nil
	case entity.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldPrice(v)
		return nil
	case entity.FieldSoldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, entity.FieldQuantity)
	}
	if m.addasset_id != nil {
		fields = append(fields, entity.FieldAssetID)
	}
	if m.addpurchase_price != nil {
		fields = append(fields, entity.FieldPurchasePrice)
	}
	if m.addsold_price != nil {
		fields = append(fields, entity.FieldSoldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldQuantity:
		return m.AddedQuantity()
	case entity.FieldAssetID:
		return m.AddedAssetID()
	case entity.FieldPurchasePrice:
		return m.AddedPurchasePrice()
	case entity.FieldSoldPrice:
		return m.AddedSoldPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entity.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case entity.FieldAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetID(v)
		return nil
	case entity.FieldPurchasePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchasePrice(v)
		return nil
	case entity.FieldSoldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoldPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entity.FieldDescription) {
		fields = append(fields, entity.FieldDescription)
	}
	if m.FieldCleared(entity.FieldImportRef) {
		fields = append(fields, entity.FieldImportRef)
	}
	if m.FieldCleared(entity.FieldNotes) {
		fields = append(fields, entity.FieldNotes)
	}
	if m.FieldCleared(entity.FieldSerialNumber) {
		fields = append(fields, entity.FieldSerialNumber)
	}
	if m.FieldCleared(entity.FieldModelNumber) {
		fields = append(fields, entity.FieldModelNumber)
	}
	if m.FieldCleared(entity.FieldManufacturer) {
		fields = append(fields, entity.FieldManufacturer)
	}
	if m.FieldCleared(entity.FieldWarrantyExpires) {
		fields = append(fields, entity.FieldWarrantyExpires)
	}
	if m.FieldCleared(entity.FieldWarrantyDetails) {
		fields = append(fields, entity.FieldWarrantyDetails)
	}
	if m.FieldCleared(entity.FieldPurchaseTime) {
		fields = append(fields, entity.FieldPurchaseTime)
	}
	if m.FieldCleared(entity.FieldPurchaseFrom) {
		fields = append(fields, entity.FieldPurchaseFrom)
	}
	if m.FieldCleared(entity.FieldSoldTime) {
		fields = append(fields, entity.FieldSoldTime)
	}
	if m.FieldCleared(entity.FieldSoldTo) {
		fields = append(fields, entity.FieldSoldTo)
	}
	if m.FieldCleared(entity.FieldSoldNotes) {
		fields = append(fields, entity.FieldSoldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	switch name {
	case entity.FieldDescription:
		m.ClearDescription()
		return nil
	case entity.FieldImportRef:
		m.ClearImportRef()
		return nil
	case entity.FieldNotes:
		m.ClearNotes()
		return nil
	case entity.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case entity.FieldModelNumber:
		m.ClearModelNumber()
		return nil
	case entity.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case entity.FieldWarrantyExpires:
		m.ClearWarrantyExpires()
		return nil
	case entity.FieldWarrantyDetails:
		m.ClearWarrantyDetails()
		return nil
	case entity.FieldPurchaseTime:
		m.ClearPurchaseTime()
		return nil
	case entity.FieldPurchaseFrom:
		m.ClearPurchaseFrom()
		return nil
	case entity.FieldSoldTime:
		m.ClearSoldTime()
		return nil
	case entity.FieldSoldTo:
		m.ClearSoldTo()
		return nil
	case entity.FieldSoldNotes:
		m.ClearSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldName:
		m.ResetName()
		return nil
	case entity.FieldDescription:
		m.ResetDescription()
		return nil
	case entity.FieldImportRef:
		m.ResetImportRef()
		return nil
	case entity.FieldNotes:
		m.ResetNotes()
		return nil
	case entity.FieldQuantity:
		m.ResetQuantity()
		return nil
	case entity.FieldInsured:
		m.ResetInsured()
		return nil
	case entity.FieldArchived:
		m.ResetArchived()
		return nil
	case entity.FieldAssetID:
		m.ResetAssetID()
		return nil
	case entity.FieldSyncChildEntitiesLocations:
		m.ResetSyncChildEntitiesLocations()
		return nil
	case entity.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case entity.FieldModelNumber:
		m.ResetModelNumber()
		return nil
	case entity.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case entity.FieldLifetimeWarranty:
		m.ResetLifetimeWarranty()
		return nil
	case entity.FieldWarrantyExpires:
		m.ResetWarrantyExpires()
		return nil
	case entity.FieldWarrantyDetails:
		m.ResetWarrantyDetails()
		return nil
	case entity.FieldPurchaseTime:
		m.ResetPurchaseTime()
		return nil
	case entity.FieldPurchaseFrom:
		m.ResetPurchaseFrom()
		return nil
	case entity.FieldPurchasePrice:
		m.ResetPurchasePrice()
		return nil
	case entity.FieldSoldTime:
		m.ResetSoldTime()
		return nil
	case entity.FieldSoldTo:
		m.ResetSoldTo()
		return nil
	case entity.FieldSoldPrice:
		m.ResetSoldPrice()
		return nil
	case entity.FieldSoldNotes:
		m.ResetSoldNotes()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.group != nil {
		edges = append(edges, entity.EdgeGroup)
	}
	if m.children != nil {
		edges = append(edges, entity.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, entity.EdgeParent)
	}
	if m.entity != nil {
		edges = append(edges, entity.EdgeEntity)
	}
	if m.location != nil {
		edges = append(edges, entity.EdgeLocation)
	}
	if m.tag != nil {
		edges = append(edges, entity.EdgeTag)
	}
	if m._type != nil {
		edges = append(edges, entity.EdgeType)
	}
	if m.fields != nil {
		edges = append(edges, entity.EdgeFields)
	}
	if m.maintenance_entries != nil {
		edges = append(edges, entity.EdgeMaintenanceEntries)
	}
	if m.attachments != nil {
		edges = append(edges, entity.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.entity))
		for id := range m.entity {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeMaintenanceEntries:
		ids := make([]ent.Value, 0, len(m.maintenance_entries))
		for id := range m.maintenance_entries {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedchildren != nil {
		edges = append(edges, entity.EdgeChildren)
	}
	if m.removedentity != nil {
		edges = append(edges, entity.EdgeEntity)
	}
	if m.removedtag != nil {
		edges = append(edges, entity.EdgeTag)
	}
	if m.removedfields != nil {
		edges = append(edges, entity.EdgeFields)
	}
	if m.removedmaintenance_entries != nil {
		edges = append(edges, entity.EdgeMaintenanceEntries)
	}
	if m.removedattachments != nil {
		edges = append(edges, entity.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.removedentity))
		for id := range m.removedentity {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeMaintenanceEntries:
		ids := make([]ent.Value, 0, len(m.removedmaintenance_entries))
		for id := range m.removedmaintenance_entries {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedgroup {
		edges = append(edges, entity.EdgeGroup)
	}
	if m.clearedchildren {
		edges = append(edges, entity.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, entity.EdgeParent)
	}
	if m.clearedentity {
		edges = append(edges, entity.EdgeEntity)
	}
	if m.clearedlocation {
		edges = append(edges, entity.EdgeLocation)
	}
	if m.clearedtag {
		edges = append(edges, entity.EdgeTag)
	}
	if m.cleared_type {
		edges = append(edges, entity.EdgeType)
	}
	if m.clearedfields {
		edges = append(edges, entity.EdgeFields)
	}
	if m.clearedmaintenance_entries {
		edges = append(edges, entity.EdgeMaintenanceEntries)
	}
	if m.clearedattachments {
		edges = append(edges, entity.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeGroup:
		return m.clearedgroup
	case entity.EdgeChildren:
		return m.clearedchildren
	case entity.EdgeParent:
		return m.clearedparent
	case entity.EdgeEntity:
		return m.clearedentity
	case entity.EdgeLocation:
		return m.clearedlocation
	case entity.EdgeTag:
		return m.clearedtag
	case entity.EdgeType:
		return m.cleared_type
	case entity.EdgeFields:
		return m.clearedfields
	case entity.EdgeMaintenanceEntries:
		return m.clearedmaintenance_entries
	case entity.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	case entity.EdgeGroup:
		m.ClearGroup()
		return nil
	case entity.EdgeParent:
		m.ClearParent()
		return nil
	case entity.EdgeLocation:
		m.ClearLocation()
		return nil
	case entity.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeGroup:
		m.ResetGroup()
		return nil
	case entity.EdgeChildren:
		m.ResetChildren()
		return nil
	case entity.EdgeParent:
		m.ResetParent()
		return nil
	case entity.EdgeEntity:
		m.ResetEntity()
		return nil
	case entity.EdgeLocation:
		m.ResetLocation()
		return nil
	case entity.EdgeTag:
		m.ResetTag()
		return nil
	case entity.EdgeType:
		m.ResetType()
		return nil
	case entity.EdgeFields:
		m.ResetFields()
		return nil
	case entity.EdgeMaintenanceEntries:
		m.ResetMaintenanceEntries()
		return nil
	case entity.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// EntityFieldMutation represents an operation that mutates the EntityField nodes in the graph.
type EntityFieldMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	_type           *entityfield.Type
	text_value      *string
	number_value    *int
	addnumber_value *int
	boolean_value   *bool
	time_value      *time.Time
	clearedFields   map[string]struct{}
	entity          *uuid.UUID
	clearedentity   bool
	done            bool
	oldValue        func(context.Context) (*EntityField, error)
	predicates      []predicate.EntityField
}

var _ ent.Mutation = (*EntityFieldMutation)(nil)

// entityfieldOption allows management of the mutation configuration using functional options.
type entityfieldOption func(*EntityFieldMutation)

// newEntityFieldMutation creates new mutation for the EntityField entity.
func newEntityFieldMutation(c config, op Op, opts ...entityfieldOption) *EntityFieldMutation {
	m := &EntityFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityFieldID sets the ID field of the mutation.
func withEntityFieldID(id uuid.UUID) entityfieldOption {
	return func(m *EntityFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityField
		)
		m.oldValue = func(ctx context.Context) (*EntityField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityField sets the old EntityField of the mutation.
func withEntityField(node *EntityField) entityfieldOption {
	return func(m *EntityFieldMutation) {
		m.oldValue = func(context.Context) (*EntityField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityField entities.
func (m *EntityFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityFieldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityFieldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityFieldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityFieldMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityFieldMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityFieldMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EntityFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityFieldMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntityFieldMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityFieldMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityFieldMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entityfield.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityFieldMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entityfield.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityFieldMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entityfield.FieldDescription)
}

// SetType sets the "type" field.
func (m *EntityFieldMutation) SetType(e entityfield.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EntityFieldMutation) GetType() (r entityfield.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldType(ctx context.Context) (v entityfield.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EntityFieldMutation) ResetType() {
	m._type = nil
}

// SetTextValue sets the "text_value" field.
func (m *EntityFieldMutation) SetTextValue(s string) {
	m.text_value = &s
}

// TextValue returns the value of the "text_value" field in the mutation.
func (m *EntityFieldMutation) TextValue() (r string, exists bool) {
	v := m.text_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTextValue returns the old "text_value" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldTextValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextValue: %w", err)
	}
	return oldValue.TextValue, nil
}

// ClearTextValue clears the value of the "text_value" field.
func (m *EntityFieldMutation) ClearTextValue() {
	m.text_value = nil
	m.clearedFields[entityfield.FieldTextValue] = struct{}{}
}

// TextValueCleared returns if the "text_value" field was cleared in this mutation.
func (m *EntityFieldMutation) TextValueCleared() bool {
	_, ok := m.clearedFields[entityfield.FieldTextValue]
	return ok
}

// ResetTextValue resets all changes to the "text_value" field.
func (m *EntityFieldMutation) ResetTextValue() {
	m.text_value = nil
	delete(m.clearedFields, entityfield.FieldTextValue)
}

// SetNumberValue sets the "number_value" field.
func (m *EntityFieldMutation) SetNumberValue(i int) {
	m.number_value = &i
	m.addnumber_value = nil
}

// NumberValue returns the value of the "number_value" field in the mutation.
func (m *EntityFieldMutation) NumberValue() (r int, exists bool) {
	v := m.number_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberValue returns the old "number_value" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldNumberValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberValue: %w", err)
	}
	return oldValue.NumberValue, nil
}

// AddNumberValue adds i to the "number_value" field.
func (m *EntityFieldMutation) AddNumberValue(i int) {
	if m.addnumber_value != nil {
		*m.addnumber_value += i
	} else {
		m.addnumber_value = &i
	}
}

// AddedNumberValue returns the value that was added to the "number_value" field in this mutation.
func (m *EntityFieldMutation) AddedNumberValue() (r int, exists bool) {
	v := m.addnumber_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberValue clears the value of the "number_value" field.
func (m *EntityFieldMutation) ClearNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	m.clearedFields[entityfield.FieldNumberValue] = struct{}{}
}

// NumberValueCleared returns if the "number_value" field was cleared in this mutation.
func (m *EntityFieldMutation) NumberValueCleared() bool {
	_, ok := m.clearedFields[entityfield.FieldNumberValue]
	return ok
}

// ResetNumberValue resets all changes to the "number_value" field.
func (m *EntityFieldMutation) ResetNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	delete(m.clearedFields, entityfield.FieldNumberValue)
}

// SetBooleanValue sets the "boolean_value" field.
func (m *EntityFieldMutation) SetBooleanValue(b bool) {
	m.boolean_value = &b
}

// BooleanValue returns the value of the "boolean_value" field in the mutation.
func (m *EntityFieldMutation) BooleanValue() (r bool, exists bool) {
	v := m.boolean_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBooleanValue returns the old "boolean_value" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldBooleanValue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBooleanValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBooleanValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBooleanValue: %w", err)
	}
	return oldValue.BooleanValue, nil
}

// ResetBooleanValue resets all changes to the "boolean_value" field.
func (m *EntityFieldMutation) ResetBooleanValue() {
	m.boolean_value = nil
}

// SetTimeValue sets the "time_value" field.
func (m *EntityFieldMutation) SetTimeValue(t time.Time) {
	m.time_value = &t
}

// TimeValue returns the value of the "time_value" field in the mutation.
func (m *EntityFieldMutation) TimeValue() (r time.Time, exists bool) {
	v := m.time_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeValue returns the old "time_value" field's value of the EntityField entity.
// If the EntityField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityFieldMutation) OldTimeValue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeValue: %w", err)
	}
	return oldValue.TimeValue, nil
}

// ResetTimeValue resets all changes to the "time_value" field.
func (m *EntityFieldMutation) ResetTimeValue() {
	m.time_value = nil
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *EntityFieldMutation) SetEntityID(id uuid.UUID) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *EntityFieldMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *EntityFieldMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *EntityFieldMutation) EntityID() (id uuid.UUID, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *EntityFieldMutation) EntityIDs() (ids []uuid.UUID) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *EntityFieldMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the EntityFieldMutation builder.
func (m *EntityFieldMutation) Where(ps ...predicate.EntityField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityField).
func (m *EntityFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityFieldMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, entityfield.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entityfield.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, entityfield.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entityfield.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, entityfield.FieldType)
	}
	if m.text_value != nil {
		fields = append(fields, entityfield.FieldTextValue)
	}
	if m.number_value != nil {
		fields = append(fields, entityfield.FieldNumberValue)
	}
	if m.boolean_value != nil {
		fields = append(fields, entityfield.FieldBooleanValue)
	}
	if m.time_value != nil {
		fields = append(fields, entityfield.FieldTimeValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entityfield.FieldCreatedAt:
		return m.CreatedAt()
	case entityfield.FieldUpdatedAt:
		return m.UpdatedAt()
	case entityfield.FieldName:
		return m.Name()
	case entityfield.FieldDescription:
		return m.Description()
	case entityfield.FieldType:
		return m.GetType()
	case entityfield.FieldTextValue:
		return m.TextValue()
	case entityfield.FieldNumberValue:
		return m.NumberValue()
	case entityfield.FieldBooleanValue:
		return m.BooleanValue()
	case entityfield.FieldTimeValue:
		return m.TimeValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entityfield.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entityfield.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entityfield.FieldName:
		return m.OldName(ctx)
	case entityfield.FieldDescription:
		return m.OldDescription(ctx)
	case entityfield.FieldType:
		return m.OldType(ctx)
	case entityfield.FieldTextValue:
		return m.OldTextValue(ctx)
	case entityfield.FieldNumberValue:
		return m.OldNumberValue(ctx)
	case entityfield.FieldBooleanValue:
		return m.OldBooleanValue(ctx)
	case entityfield.FieldTimeValue:
		return m.OldTimeValue(ctx)
	}
	return nil, fmt.Errorf("unknown EntityField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entityfield.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entityfield.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entityfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entityfield.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entityfield.FieldType:
		v, ok := value.(entityfield.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case entityfield.FieldTextValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextValue(v)
		return nil
	case entityfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberValue(v)
		return nil
	case entityfield.FieldBooleanValue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBooleanValue(v)
		return nil
	case entityfield.FieldTimeValue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeValue(v)
		return nil
	}
	return fmt.Errorf("unknown EntityField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityFieldMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_value != nil {
		fields = append(fields, entityfield.FieldNumberValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entityfield.FieldNumberValue:
		return m.AddedNumberValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entityfield.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberValue(v)
		return nil
	}
	return fmt.Errorf("unknown EntityField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entityfield.FieldDescription) {
		fields = append(fields, entityfield.FieldDescription)
	}
	if m.FieldCleared(entityfield.FieldTextValue) {
		fields = append(fields, entityfield.FieldTextValue)
	}
	if m.FieldCleared(entityfield.FieldNumberValue) {
		fields = append(fields, entityfield.FieldNumberValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityFieldMutation) ClearField(name string) error {
	switch name {
	case entityfield.FieldDescription:
		m.ClearDescription()
		return nil
	case entityfield.FieldTextValue:
		m.ClearTextValue()
		return nil
	case entityfield.FieldNumberValue:
		m.ClearNumberValue()
		return nil
	}
	return fmt.Errorf("unknown EntityField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityFieldMutation) ResetField(name string) error {
	switch name {
	case entityfield.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entityfield.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entityfield.FieldName:
		m.ResetName()
		return nil
	case entityfield.FieldDescription:
		m.ResetDescription()
		return nil
	case entityfield.FieldType:
		m.ResetType()
		return nil
	case entityfield.FieldTextValue:
		m.ResetTextValue()
		return nil
	case entityfield.FieldNumberValue:
		m.ResetNumberValue()
		return nil
	case entityfield.FieldBooleanValue:
		m.ResetBooleanValue()
		return nil
	case entityfield.FieldTimeValue:
		m.ResetTimeValue()
		return nil
	}
	return fmt.Errorf("unknown EntityField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, entityfield.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entityfield.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, entityfield.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case entityfield.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityFieldMutation) ClearEdge(name string) error {
	switch name {
	case entityfield.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown EntityField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityFieldMutation) ResetEdge(name string) error {
	switch name {
	case entityfield.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown EntityField edge %s", name)
}

// EntityTypeMutation represents an operation that mutates the EntityType nodes in the graph.
type EntityTypeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	icon            *string
	color           *string
	is_location     *bool
	clearedFields   map[string]struct{}
	group           *uuid.UUID
	clearedgroup    bool
	entities        map[uuid.UUID]struct{}
	removedentities map[uuid.UUID]struct{}
	clearedentities bool
	done            bool
	oldValue        func(context.Context) (*EntityType, error)
	predicates      []predicate.EntityType
}

var _ ent.Mutation = (*EntityTypeMutation)(nil)

// entitytypeOption allows management of the mutation configuration using functional options.
type entitytypeOption func(*EntityTypeMutation)

// newEntityTypeMutation creates new mutation for the EntityType entity.
func newEntityTypeMutation(c config, op Op, opts ...entitytypeOption) *EntityTypeMutation {
	m := &EntityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityTypeID sets the ID field of the mutation.
func withEntityTypeID(id uuid.UUID) entitytypeOption {
	return func(m *EntityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityType
		)
		m.oldValue = func(ctx context.Context) (*EntityType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityType sets the old EntityType of the mutation.
func withEntityType(node *EntityType) entitytypeOption {
	return func(m *EntityTypeMutation) {
		m.oldValue = func(context.Context) (*EntityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityType entities.
func (m *EntityTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EntityTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntityTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entitytype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entitytype.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *EntityTypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *EntityTypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *EntityTypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[entitytype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *EntityTypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *EntityTypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, entitytype.FieldIcon)
}

// SetColor sets the "color" field.
func (m *EntityTypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *EntityTypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *EntityTypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[entitytype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *EntityTypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *EntityTypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, entitytype.FieldColor)
}

// SetIsLocation sets the "is_location" field.
func (m *EntityTypeMutation) SetIsLocation(b bool) {
	m.is_location = &b
}

// IsLocation returns the value of the "is_location" field in the mutation.
func (m *EntityTypeMutation) IsLocation() (r bool, exists bool) {
	v := m.is_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLocation returns the old "is_location" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldIsLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLocation: %w", err)
	}
	return oldValue.IsLocation, nil
}

// ResetIsLocation resets all changes to the "is_location" field.
func (m *EntityTypeMutation) ResetIsLocation() {
	m.is_location = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *EntityTypeMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *EntityTypeMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *EntityTypeMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *EntityTypeMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *EntityTypeMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *EntityTypeMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *EntityTypeMutation) AddEntityIDs(ids ...uuid.UUID) {
	if m.entities == nil {
		m.entities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *EntityTypeMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *EntityTypeMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *EntityTypeMutation) RemoveEntityIDs(ids ...uuid.UUID) {
	if m.removedentities == nil {
		m.removedentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *EntityTypeMutation) RemovedEntitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *EntityTypeMutation) EntitiesIDs() (ids []uuid.UUID) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *EntityTypeMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the EntityTypeMutation builder.
func (m *EntityTypeMutation) Where(ps ...predicate.EntityType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityType).
func (m *EntityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, entitytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitytype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, entitytype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entitytype.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, entitytype.FieldIcon)
	}
	if m.color != nil {
		fields = append(fields, entitytype.FieldColor)
	}
	if m.is_location != nil {
		fields = append(fields, entitytype.FieldIsLocation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitytype.FieldCreatedAt:
		return m.CreatedAt()
	case entitytype.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitytype.FieldName:
		return m.Name()
	case entitytype.FieldDescription:
		return m.Description()
	case entitytype.FieldIcon:
		return m.Icon()
	case entitytype.FieldColor:
		return m.Color()
	case entitytype.FieldIsLocation:
		return m.IsLocation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitytype.FieldName:
		return m.OldName(ctx)
	case entitytype.FieldDescription:
		return m.OldDescription(ctx)
	case entitytype.FieldIcon:
		return m.OldIcon(ctx)
	case entitytype.FieldColor:
		return m.OldColor(ctx)
	case entitytype.FieldIsLocation:
		return m.OldIsLocation(ctx)
	}
	return nil, fmt.Errorf("unknown EntityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entitytype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entitytype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case entitytype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case entitytype.FieldIsLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLocation(v)
		return nil
	}
	return fmt.Errorf("unknown EntityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitytype.FieldDescription) {
		fields = append(fields, entitytype.FieldDescription)
	}
	if m.FieldCleared(entitytype.FieldIcon) {
		fields = append(fields, entitytype.FieldIcon)
	}
	if m.FieldCleared(entitytype.FieldColor) {
		fields = append(fields, entitytype.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityTypeMutation) ClearField(name string) error {
	switch name {
	case entitytype.FieldDescription:
		m.ClearDescription()
		return nil
	case entitytype.FieldIcon:
		m.ClearIcon()
		return nil
	case entitytype.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown EntityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityTypeMutation) ResetField(name string) error {
	switch name {
	case entitytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitytype.FieldName:
		m.ResetName()
		return nil
	case entitytype.FieldDescription:
		m.ResetDescription()
		return nil
	case entitytype.FieldIcon:
		m.ResetIcon()
		return nil
	case entitytype.FieldColor:
		m.ResetColor()
		return nil
	case entitytype.FieldIsLocation:
		m.ResetIsLocation()
		return nil
	}
	return fmt.Errorf("unknown EntityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, entitytype.EdgeGroup)
	}
	if m.entities != nil {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitytype.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case entitytype.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentities != nil {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitytype.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, entitytype.EdgeGroup)
	}
	if m.clearedentities {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case entitytype.EdgeGroup:
		return m.clearedgroup
	case entitytype.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityTypeMutation) ClearEdge(name string) error {
	switch name {
	case entitytype.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown EntityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityTypeMutation) ResetEdge(name string) error {
	switch name {
	case entitytype.EdgeGroup:
		m.ResetGroup()
		return nil
	case entitytype.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown EntityType edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	name                     *string
	currency                 *string
	clearedFields            map[string]struct{}
	users                    map[uuid.UUID]struct{}
	removedusers             map[uuid.UUID]struct{}
	clearedusers             bool
	entities                 map[uuid.UUID]struct{}
	removedentities          map[uuid.UUID]struct{}
	clearedentities          bool
	tags                     map[uuid.UUID]struct{}
	removedtags              map[uuid.UUID]struct{}
	clearedtags              bool
	invitation_tokens        map[uuid.UUID]struct{}
	removedinvitation_tokens map[uuid.UUID]struct{}
	clearedinvitation_tokens bool
	notifiers                map[uuid.UUID]struct{}
	removednotifiers         map[uuid.UUID]struct{}
	clearednotifiers         bool
	entity_types             map[uuid.UUID]struct{}
	removedentity_types      map[uuid.UUID]struct{}
	clearedentity_types      bool
	item_templates           map[uuid.UUID]struct{}
	removeditem_templates    map[uuid.UUID]struct{}
	cleareditem_templates    bool
	done                     bool
	oldValue                 func(context.Context) (*Group, error)
	predicates               []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id uuid.UUID) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetCurrency sets the "currency" field.
func (m *GroupMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *GroupMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *GroupMutation) ResetCurrency() {
	m.currency = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *GroupMutation) AddEntityIDs(ids ...uuid.UUID) {
	if m.entities == nil {
		m.entities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *GroupMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *GroupMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *GroupMutation) RemoveEntityIDs(ids ...uuid.UUID) {
	if m.removedentities == nil {
		m.removedentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *GroupMutation) RemovedEntitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *GroupMutation) EntitiesIDs() (ids []uuid.UUID) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *GroupMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *GroupMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *GroupMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *GroupMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *GroupMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *GroupMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *GroupMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *GroupMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddInvitationTokenIDs adds the "invitation_tokens" edge to the GroupInvitationToken entity by ids.
func (m *GroupMutation) AddInvitationTokenIDs(ids ...uuid.UUID) {
	if m.invitation_tokens == nil {
		m.invitation_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_tokens[ids[i]] = struct{}{}
	}
}

// ClearInvitationTokens clears the "invitation_tokens" edge to the GroupInvitationToken entity.
func (m *GroupMutation) ClearInvitationTokens() {
	m.clearedinvitation_tokens = true
}

// InvitationTokensCleared reports if the "invitation_tokens" edge to the GroupInvitationToken entity was cleared.
func (m *GroupMutation) InvitationTokensCleared() bool {
	return m.clearedinvitation_tokens
}

// RemoveInvitationTokenIDs removes the "invitation_tokens" edge to the GroupInvitationToken entity by IDs.
func (m *GroupMutation) RemoveInvitationTokenIDs(ids ...uuid.UUID) {
	if m.removedinvitation_tokens == nil {
		m.removedinvitation_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_tokens, ids[i])
		m.removedinvitation_tokens[ids[i]] = struct{}{}
	}
}

// RemovedInvitationTokens returns the removed IDs of the "invitation_tokens" edge to the GroupInvitationToken entity.
func (m *GroupMutation) RemovedInvitationTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_tokens {
		ids = append(ids, id)
	}
	return
}

// InvitationTokensIDs returns the "invitation_tokens" edge IDs in the mutation.
func (m *GroupMutation) InvitationTokensIDs() (ids []uuid.UUID) {
	for id := range m.invitation_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationTokens resets all changes to the "invitation_tokens" edge.
func (m *GroupMutation) ResetInvitationTokens() {
	m.invitation_tokens = nil
	m.clearedinvitation_tokens = false
	m.removedinvitation_tokens = nil
}

// AddNotifierIDs adds the "notifiers" edge to the Notifier entity by ids.
func (m *GroupMutation) AddNotifierIDs(ids ...uuid.UUID) {
	if m.notifiers == nil {
		m.notifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifiers[ids[i]] = struct{}{}
	}
}

// ClearNotifiers clears the "notifiers" edge to the Notifier entity.
func (m *GroupMutation) ClearNotifiers() {
	m.clearednotifiers = true
}

// NotifiersCleared reports if the "notifiers" edge to the Notifier entity was cleared.
func (m *GroupMutation) NotifiersCleared() bool {
	return m.clearednotifiers
}

// RemoveNotifierIDs removes the "notifiers" edge to the Notifier entity by IDs.
func (m *GroupMutation) RemoveNotifierIDs(ids ...uuid.UUID) {
	if m.removednotifiers == nil {
		m.removednotifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifiers, ids[i])
		m.removednotifiers[ids[i]] = struct{}{}
	}
}

// RemovedNotifiers returns the removed IDs of the "notifiers" edge to the Notifier entity.
func (m *GroupMutation) RemovedNotifiersIDs() (ids []uuid.UUID) {
	for id := range m.removednotifiers {
		ids = append(ids, id)
	}
	return
}

// NotifiersIDs returns the "notifiers" edge IDs in the mutation.
func (m *GroupMutation) NotifiersIDs() (ids []uuid.UUID) {
	for id := range m.notifiers {
		ids = append(ids, id)
	}
	return
}

// ResetNotifiers resets all changes to the "notifiers" edge.
func (m *GroupMutation) ResetNotifiers() {
	m.notifiers = nil
	m.clearednotifiers = false
	m.removednotifiers = nil
}

// AddEntityTypeIDs adds the "entity_types" edge to the EntityType entity by ids.
func (m *GroupMutation) AddEntityTypeIDs(ids ...uuid.UUID) {
	if m.entity_types == nil {
		m.entity_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entity_types[ids[i]] = struct{}{}
	}
}

// ClearEntityTypes clears the "entity_types" edge to the EntityType entity.
func (m *GroupMutation) ClearEntityTypes() {
	m.clearedentity_types = true
}

// EntityTypesCleared reports if the "entity_types" edge to the EntityType entity was cleared.
func (m *GroupMutation) EntityTypesCleared() bool {
	return m.clearedentity_types
}

// RemoveEntityTypeIDs removes the "entity_types" edge to the EntityType entity by IDs.
func (m *GroupMutation) RemoveEntityTypeIDs(ids ...uuid.UUID) {
	if m.removedentity_types == nil {
		m.removedentity_types = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entity_types, ids[i])
		m.removedentity_types[ids[i]] = struct{}{}
	}
}

// RemovedEntityTypes returns the removed IDs of the "entity_types" edge to the EntityType entity.
func (m *GroupMutation) RemovedEntityTypesIDs() (ids []uuid.UUID) {
	for id := range m.removedentity_types {
		ids = append(ids, id)
	}
	return
}

// EntityTypesIDs returns the "entity_types" edge IDs in the mutation.
func (m *GroupMutation) EntityTypesIDs() (ids []uuid.UUID) {
	for id := range m.entity_types {
		ids = append(ids, id)
	}
	return
}

// ResetEntityTypes resets all changes to the "entity_types" edge.
func (m *GroupMutation) ResetEntityTypes() {
	m.entity_types = nil
	m.clearedentity_types = false
	m.removedentity_types = nil
}

// AddItemTemplateIDs adds the "item_templates" edge to the ItemTemplate entity by ids.
func (m *GroupMutation) AddItemTemplateIDs(ids ...uuid.UUID) {
	if m.item_templates == nil {
		m.item_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.item_templates[ids[i]] = struct{}{}
	}
}

// ClearItemTemplates clears the "item_templates" edge to the ItemTemplate entity.
func (m *GroupMutation) ClearItemTemplates() {
	m.cleareditem_templates = true
}

// ItemTemplatesCleared reports if the "item_templates" edge to the ItemTemplate entity was cleared.
func (m *GroupMutation) ItemTemplatesCleared() bool {
	return m.cleareditem_templates
}

// RemoveItemTemplateIDs removes the "item_templates" edge to the ItemTemplate entity by IDs.
func (m *GroupMutation) RemoveItemTemplateIDs(ids ...uuid.UUID) {
	if m.removeditem_templates == nil {
		m.removeditem_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.item_templates, ids[i])
		m.removeditem_templates[ids[i]] = struct{}{}
	}
}

// RemovedItemTemplates returns the removed IDs of the "item_templates" edge to the ItemTemplate entity.
func (m *GroupMutation) RemovedItemTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.removeditem_templates {
		ids = append(ids, id)
	}
	return
}

// ItemTemplatesIDs returns the "item_templates" edge IDs in the mutation.
func (m *GroupMutation) ItemTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.item_templates {
		ids = append(ids, id)
	}
	return
}

// ResetItemTemplates resets all changes to the "item_templates" edge.
func (m *GroupMutation) ResetItemTemplates() {
	m.item_templates = nil
	m.cleareditem_templates = false
	m.removeditem_templates = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.currency != nil {
		fields = append(fields, group.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.entities != nil {
		edges = append(edges, group.EdgeEntities)
	}
	if m.tags != nil {
		edges = append(edges, group.EdgeTags)
	}
	if m.invitation_tokens != nil {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.notifiers != nil {
		edges = append(edges, group.EdgeNotifiers)
	}
	if m.entity_types != nil {
		edges = append(edges, group.EdgeEntityTypes)
	}
	if m.item_templates != nil {
		edges = append(edges, group.EdgeItemTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeInvitationTokens:
		ids := make([]ent.Value, 0, len(m.invitation_tokens))
		for id := range m.invitation_tokens {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.notifiers))
		for id := range m.notifiers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEntityTypes:
		ids := make([]ent.Value, 0, len(m.entity_types))
		for id := range m.entity_types {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItemTemplates:
		ids := make([]ent.Value, 0, len(m.item_templates))
		for id := range m.item_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.removedentities != nil {
		edges = append(edges, group.EdgeEntities)
	}
	if m.removedtags != nil {
		edges = append(edges, group.EdgeTags)
	}
	if m.removedinvitation_tokens != nil {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.removednotifiers != nil {
		edges = append(edges, group.EdgeNotifiers)
	}
	if m.removedentity_types != nil {
		edges = append(edges, group.EdgeEntityTypes)
	}
	if m.removeditem_templates != nil {
		edges = append(edges, group.EdgeItemTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeInvitationTokens:
		ids := make([]ent.Value, 0, len(m.removedinvitation_tokens))
		for id := range m.removedinvitation_tokens {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.removednotifiers))
		for id := range m.removednotifiers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEntityTypes:
		ids := make([]ent.Value, 0, len(m.removedentity_types))
		for id := range m.removedentity_types {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeItemTemplates:
		ids := make([]ent.Value, 0, len(m.removeditem_templates))
		for id := range m.removeditem_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedentities {
		edges = append(edges, group.EdgeEntities)
	}
	if m.clearedtags {
		edges = append(edges, group.EdgeTags)
	}
	if m.clearedinvitation_tokens {
		edges = append(edges, group.EdgeInvitationTokens)
	}
	if m.clearednotifiers {
		edges = append(edges, group.EdgeNotifiers)
	}
	if m.clearedentity_types {
		edges = append(edges, group.EdgeEntityTypes)
	}
	if m.cleareditem_templates {
		edges = append(edges, group.EdgeItemTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeEntities:
		return m.clearedentities
	case group.EdgeTags:
		return m.clearedtags
	case group.EdgeInvitationTokens:
		return m.clearedinvitation_tokens
	case group.EdgeNotifiers:
		return m.clearednotifiers
	case group.EdgeEntityTypes:
		return m.clearedentity_types
	case group.EdgeItemTemplates:
		return m.cleareditem_templates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeEntities:
		m.ResetEntities()
		return nil
	case group.EdgeTags:
		m.ResetTags()
		return nil
	case group.EdgeInvitationTokens:
		m.ResetInvitationTokens()
		return nil
	case group.EdgeNotifiers:
		m.ResetNotifiers()
		return nil
	case group.EdgeEntityTypes:
		m.ResetEntityTypes()
		return nil
	case group.EdgeItemTemplates:
		m.ResetItemTemplates()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupInvitationTokenMutation represents an operation that mutates the GroupInvitationToken nodes in the graph.
type GroupInvitationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	token         *[]byte
	expires_at    *time.Time
	uses          *int
	adduses       *int
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*GroupInvitationToken, error)
	predicates    []predicate.GroupInvitationToken
}

var _ ent.Mutation = (*GroupInvitationTokenMutation)(nil)

// groupinvitationtokenOption allows management of the mutation configuration using functional options.
type groupinvitationtokenOption func(*GroupInvitationTokenMutation)

// newGroupInvitationTokenMutation creates new mutation for the GroupInvitationToken entity.
func newGroupInvitationTokenMutation(c config, op Op, opts ...groupinvitationtokenOption) *GroupInvitationTokenMutation {
	m := &GroupInvitationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupInvitationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupInvitationTokenID sets the ID field of the mutation.
func withGroupInvitationTokenID(id uuid.UUID) groupinvitationtokenOption {
	return func(m *GroupInvitationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupInvitationToken
		)
		m.oldValue = func(ctx context.Context) (*GroupInvitationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupInvitationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupInvitationToken sets the old GroupInvitationToken of the mutation.
func withGroupInvitationToken(node *GroupInvitationToken) groupinvitationtokenOption {
	return func(m *GroupInvitationTokenMutation) {
		m.oldValue = func(context.Context) (*GroupInvitationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupInvitationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupInvitationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupInvitationToken entities.
func (m *GroupInvitationTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupInvitationTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupInvitationTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupInvitationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupInvitationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupInvitationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupInvitationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupInvitationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupInvitationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupInvitationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *GroupInvitationTokenMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *GroupInvitationTokenMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *GroupInvitationTokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *GroupInvitationTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *GroupInvitationTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *GroupInvitationTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUses sets the "uses" field.
func (m *GroupInvitationTokenMutation) SetUses(i int) {
	m.uses = &i
	m.adduses = nil
}

// Uses returns the value of the "uses" field in the mutation.
func (m *GroupInvitationTokenMutation) Uses() (r int, exists bool) {
	v := m.uses
	if v == nil {
		return
	}
	return *v, true
}

// OldUses returns the old "uses" field's value of the GroupInvitationToken entity.
// If the GroupInvitationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupInvitationTokenMutation) OldUses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUses: %w", err)
	}
	return oldValue.Uses, nil
}

// AddUses adds i to the "uses" field.
func (m *GroupInvitationTokenMutation) AddUses(i int) {
	if m.adduses != nil {
		*m.adduses += i
	} else {
		m.adduses = &i
	}
}

// AddedUses returns the value that was added to the "uses" field in this mutation.
func (m *GroupInvitationTokenMutation) AddedUses() (r int, exists bool) {
	v := m.adduses
	if v == nil {
		return
	}
	return *v, true
}

// ResetUses resets all changes to the "uses" field.
func (m *GroupInvitationTokenMutation) ResetUses() {
	m.uses = nil
	m.adduses = nil
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *GroupInvitationTokenMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *GroupInvitationTokenMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *GroupInvitationTokenMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *GroupInvitationTokenMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *GroupInvitationTokenMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *GroupInvitationTokenMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the GroupInvitationTokenMutation builder.
func (m *GroupInvitationTokenMutation) Where(ps ...predicate.GroupInvitationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupInvitationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupInvitationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupInvitationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupInvitationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupInvitationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupInvitationToken).
func (m *GroupInvitationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupInvitationTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, groupinvitationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupinvitationtoken.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, groupinvitationtoken.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, groupinvitationtoken.FieldExpiresAt)
	}
	if m.uses != nil {
		fields = append(fields, groupinvitationtoken.FieldUses)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupInvitationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case groupinvitationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupinvitationtoken.FieldToken:
		return m.Token()
	case groupinvitationtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case groupinvitationtoken.FieldUses:
		return m.Uses()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupInvitationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupinvitationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupinvitationtoken.FieldToken:
		return m.OldToken(ctx)
	case groupinvitationtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case groupinvitationtoken.FieldUses:
		return m.OldUses(ctx)
	}
	return nil, fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupInvitationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupinvitationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupinvitationtoken.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case groupinvitationtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case groupinvitationtoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUses(v)
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupInvitationTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduses != nil {
		fields = append(fields, groupinvitationtoken.FieldUses)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupInvitationTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupinvitationtoken.FieldUses:
		return m.AddedUses()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupInvitationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupinvitationtoken.FieldUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUses(v)
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupInvitationTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupInvitationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupInvitationTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroupInvitationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupInvitationTokenMutation) ResetField(name string) error {
	switch name {
	case groupinvitationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupinvitationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupinvitationtoken.FieldToken:
		m.ResetToken()
		return nil
	case groupinvitationtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case groupinvitationtoken.FieldUses:
		m.ResetUses()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupInvitationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, groupinvitationtoken.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupInvitationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupInvitationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupInvitationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupInvitationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, groupinvitationtoken.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupInvitationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupInvitationTokenMutation) ClearEdge(name string) error {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupInvitationTokenMutation) ResetEdge(name string) error {
	switch name {
	case groupinvitationtoken.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupInvitationToken edge %s", name)
}

// ItemTemplateMutation represents an operation that mutates the ItemTemplate nodes in the graph.
type ItemTemplateMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	name                      *string
	description               *string
	notes                     *string
	default_quantity          *int
	adddefault_quantity       *int
	default_insured           *bool
	default_name              *string
	default_description       *string
	default_manufacturer      *string
	default_model_number      *string
	default_lifetime_warranty *bool
	default_warranty_details  *string
	include_warranty_fields   *bool
	include_purchase_fields   *bool
	include_sold_fields       *bool
	default_tag_ids           *[]uuid.UUID
	appenddefault_tag_ids     []uuid.UUID
	clearedFields             map[string]struct{}
	group                     *uuid.UUID
	clearedgroup              bool
	fields                    map[uuid.UUID]struct{}
	removedfields             map[uuid.UUID]struct{}
	clearedfields             bool
	location                  *uuid.UUID
	clearedlocation           bool
	done                      bool
	oldValue                  func(context.Context) (*ItemTemplate, error)
	predicates                []predicate.ItemTemplate
}

var _ ent.Mutation = (*ItemTemplateMutation)(nil)

// itemtemplateOption allows management of the mutation configuration using functional options.
type itemtemplateOption func(*ItemTemplateMutation)

// newItemTemplateMutation creates new mutation for the ItemTemplate entity.
func newItemTemplateMutation(c config, op Op, opts ...itemtemplateOption) *ItemTemplateMutation {
	m := &ItemTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeItemTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemTemplateID sets the ID field of the mutation.
func withItemTemplateID(id uuid.UUID) itemtemplateOption {
	return func(m *ItemTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ItemTemplate
		)
		m.oldValue = func(ctx context.Context) (*ItemTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ItemTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItemTemplate sets the old ItemTemplate of the mutation.
func withItemTemplate(node *ItemTemplate) itemtemplateOption {
	return func(m *ItemTemplateMutation) {
		m.oldValue = func(context.Context) (*ItemTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ItemTemplate entities.
func (m *ItemTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ItemTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ItemTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ItemTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ItemTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ItemTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[itemtemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ItemTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ItemTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, itemtemplate.FieldDescription)
}

// SetNotes sets the "notes" field.
func (m *ItemTemplateMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ItemTemplateMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ItemTemplateMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[itemtemplate.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ItemTemplateMutation) NotesCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ItemTemplateMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, itemtemplate.FieldNotes)
}

// SetDefaultQuantity sets the "default_quantity" field.
func (m *ItemTemplateMutation) SetDefaultQuantity(i int) {
	m.default_quantity = &i
	m.adddefault_quantity = nil
}

// DefaultQuantity returns the value of the "default_quantity" field in the mutation.
func (m *ItemTemplateMutation) DefaultQuantity() (r int, exists bool) {
	v := m.default_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultQuantity returns the old "default_quantity" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultQuantity: %w", err)
	}
	return oldValue.DefaultQuantity, nil
}

// AddDefaultQuantity adds i to the "default_quantity" field.
func (m *ItemTemplateMutation) AddDefaultQuantity(i int) {
	if m.adddefault_quantity != nil {
		*m.adddefault_quantity += i
	} else {
		m.adddefault_quantity = &i
	}
}

// AddedDefaultQuantity returns the value that was added to the "default_quantity" field in this mutation.
func (m *ItemTemplateMutation) AddedDefaultQuantity() (r int, exists bool) {
	v := m.adddefault_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultQuantity resets all changes to the "default_quantity" field.
func (m *ItemTemplateMutation) ResetDefaultQuantity() {
	m.default_quantity = nil
	m.adddefault_quantity = nil
}

// SetDefaultInsured sets the "default_insured" field.
func (m *ItemTemplateMutation) SetDefaultInsured(b bool) {
	m.default_insured = &b
}

// DefaultInsured returns the value of the "default_insured" field in the mutation.
func (m *ItemTemplateMutation) DefaultInsured() (r bool, exists bool) {
	v := m.default_insured
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultInsured returns the old "default_insured" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultInsured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultInsured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultInsured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultInsured: %w", err)
	}
	return oldValue.DefaultInsured, nil
}

// ResetDefaultInsured resets all changes to the "default_insured" field.
func (m *ItemTemplateMutation) ResetDefaultInsured() {
	m.default_insured = nil
}

// SetDefaultName sets the "default_name" field.
func (m *ItemTemplateMutation) SetDefaultName(s string) {
	m.default_name = &s
}

// DefaultName returns the value of the "default_name" field in the mutation.
func (m *ItemTemplateMutation) DefaultName() (r string, exists bool) {
	v := m.default_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultName returns the old "default_name" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultName: %w", err)
	}
	return oldValue.DefaultName, nil
}

// ClearDefaultName clears the value of the "default_name" field.
func (m *ItemTemplateMutation) ClearDefaultName() {
	m.default_name = nil
	m.clearedFields[itemtemplate.FieldDefaultName] = struct{}{}
}

// DefaultNameCleared returns if the "default_name" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultNameCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultName]
	return ok
}

// ResetDefaultName resets all changes to the "default_name" field.
func (m *ItemTemplateMutation) ResetDefaultName() {
	m.default_name = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultName)
}

// SetDefaultDescription sets the "default_description" field.
func (m *ItemTemplateMutation) SetDefaultDescription(s string) {
	m.default_description = &s
}

// DefaultDescription returns the value of the "default_description" field in the mutation.
func (m *ItemTemplateMutation) DefaultDescription() (r string, exists bool) {
	v := m.default_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultDescription returns the old "default_description" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultDescription: %w", err)
	}
	return oldValue.DefaultDescription, nil
}

// ClearDefaultDescription clears the value of the "default_description" field.
func (m *ItemTemplateMutation) ClearDefaultDescription() {
	m.default_description = nil
	m.clearedFields[itemtemplate.FieldDefaultDescription] = struct{}{}
}

// DefaultDescriptionCleared returns if the "default_description" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultDescriptionCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultDescription]
	return ok
}

// ResetDefaultDescription resets all changes to the "default_description" field.
func (m *ItemTemplateMutation) ResetDefaultDescription() {
	m.default_description = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultDescription)
}

// SetDefaultManufacturer sets the "default_manufacturer" field.
func (m *ItemTemplateMutation) SetDefaultManufacturer(s string) {
	m.default_manufacturer = &s
}

// DefaultManufacturer returns the value of the "default_manufacturer" field in the mutation.
func (m *ItemTemplateMutation) DefaultManufacturer() (r string, exists bool) {
	v := m.default_manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultManufacturer returns the old "default_manufacturer" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultManufacturer: %w", err)
	}
	return oldValue.DefaultManufacturer, nil
}

// ClearDefaultManufacturer clears the value of the "default_manufacturer" field.
func (m *ItemTemplateMutation) ClearDefaultManufacturer() {
	m.default_manufacturer = nil
	m.clearedFields[itemtemplate.FieldDefaultManufacturer] = struct{}{}
}

// DefaultManufacturerCleared returns if the "default_manufacturer" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultManufacturerCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultManufacturer]
	return ok
}

// ResetDefaultManufacturer resets all changes to the "default_manufacturer" field.
func (m *ItemTemplateMutation) ResetDefaultManufacturer() {
	m.default_manufacturer = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultManufacturer)
}

// SetDefaultModelNumber sets the "default_model_number" field.
func (m *ItemTemplateMutation) SetDefaultModelNumber(s string) {
	m.default_model_number = &s
}

// DefaultModelNumber returns the value of the "default_model_number" field in the mutation.
func (m *ItemTemplateMutation) DefaultModelNumber() (r string, exists bool) {
	v := m.default_model_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultModelNumber returns the old "default_model_number" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultModelNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultModelNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultModelNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultModelNumber: %w", err)
	}
	return oldValue.DefaultModelNumber, nil
}

// ClearDefaultModelNumber clears the value of the "default_model_number" field.
func (m *ItemTemplateMutation) ClearDefaultModelNumber() {
	m.default_model_number = nil
	m.clearedFields[itemtemplate.FieldDefaultModelNumber] = struct{}{}
}

// DefaultModelNumberCleared returns if the "default_model_number" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultModelNumberCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultModelNumber]
	return ok
}

// ResetDefaultModelNumber resets all changes to the "default_model_number" field.
func (m *ItemTemplateMutation) ResetDefaultModelNumber() {
	m.default_model_number = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultModelNumber)
}

// SetDefaultLifetimeWarranty sets the "default_lifetime_warranty" field.
func (m *ItemTemplateMutation) SetDefaultLifetimeWarranty(b bool) {
	m.default_lifetime_warranty = &b
}

// DefaultLifetimeWarranty returns the value of the "default_lifetime_warranty" field in the mutation.
func (m *ItemTemplateMutation) DefaultLifetimeWarranty() (r bool, exists bool) {
	v := m.default_lifetime_warranty
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultLifetimeWarranty returns the old "default_lifetime_warranty" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultLifetimeWarranty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultLifetimeWarranty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultLifetimeWarranty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultLifetimeWarranty: %w", err)
	}
	return oldValue.DefaultLifetimeWarranty, nil
}

// ResetDefaultLifetimeWarranty resets all changes to the "default_lifetime_warranty" field.
func (m *ItemTemplateMutation) ResetDefaultLifetimeWarranty() {
	m.default_lifetime_warranty = nil
}

// SetDefaultWarrantyDetails sets the "default_warranty_details" field.
func (m *ItemTemplateMutation) SetDefaultWarrantyDetails(s string) {
	m.default_warranty_details = &s
}

// DefaultWarrantyDetails returns the value of the "default_warranty_details" field in the mutation.
func (m *ItemTemplateMutation) DefaultWarrantyDetails() (r string, exists bool) {
	v := m.default_warranty_details
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultWarrantyDetails returns the old "default_warranty_details" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultWarrantyDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultWarrantyDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultWarrantyDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultWarrantyDetails: %w", err)
	}
	return oldValue.DefaultWarrantyDetails, nil
}

// ClearDefaultWarrantyDetails clears the value of the "default_warranty_details" field.
func (m *ItemTemplateMutation) ClearDefaultWarrantyDetails() {
	m.default_warranty_details = nil
	m.clearedFields[itemtemplate.FieldDefaultWarrantyDetails] = struct{}{}
}

// DefaultWarrantyDetailsCleared returns if the "default_warranty_details" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultWarrantyDetailsCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultWarrantyDetails]
	return ok
}

// ResetDefaultWarrantyDetails resets all changes to the "default_warranty_details" field.
func (m *ItemTemplateMutation) ResetDefaultWarrantyDetails() {
	m.default_warranty_details = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultWarrantyDetails)
}

// SetIncludeWarrantyFields sets the "include_warranty_fields" field.
func (m *ItemTemplateMutation) SetIncludeWarrantyFields(b bool) {
	m.include_warranty_fields = &b
}

// IncludeWarrantyFields returns the value of the "include_warranty_fields" field in the mutation.
func (m *ItemTemplateMutation) IncludeWarrantyFields() (r bool, exists bool) {
	v := m.include_warranty_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeWarrantyFields returns the old "include_warranty_fields" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldIncludeWarrantyFields(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludeWarrantyFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludeWarrantyFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeWarrantyFields: %w", err)
	}
	return oldValue.IncludeWarrantyFields, nil
}

// ResetIncludeWarrantyFields resets all changes to the "include_warranty_fields" field.
func (m *ItemTemplateMutation) ResetIncludeWarrantyFields() {
	m.include_warranty_fields = nil
}

// SetIncludePurchaseFields sets the "include_purchase_fields" field.
func (m *ItemTemplateMutation) SetIncludePurchaseFields(b bool) {
	m.include_purchase_fields = &b
}

// IncludePurchaseFields returns the value of the "include_purchase_fields" field in the mutation.
func (m *ItemTemplateMutation) IncludePurchaseFields() (r bool, exists bool) {
	v := m.include_purchase_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludePurchaseFields returns the old "include_purchase_fields" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldIncludePurchaseFields(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludePurchaseFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludePurchaseFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludePurchaseFields: %w", err)
	}
	return oldValue.IncludePurchaseFields, nil
}

// ResetIncludePurchaseFields resets all changes to the "include_purchase_fields" field.
func (m *ItemTemplateMutation) ResetIncludePurchaseFields() {
	m.include_purchase_fields = nil
}

// SetIncludeSoldFields sets the "include_sold_fields" field.
func (m *ItemTemplateMutation) SetIncludeSoldFields(b bool) {
	m.include_sold_fields = &b
}

// IncludeSoldFields returns the value of the "include_sold_fields" field in the mutation.
func (m *ItemTemplateMutation) IncludeSoldFields() (r bool, exists bool) {
	v := m.include_sold_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeSoldFields returns the old "include_sold_fields" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldIncludeSoldFields(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludeSoldFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludeSoldFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeSoldFields: %w", err)
	}
	return oldValue.IncludeSoldFields, nil
}

// ResetIncludeSoldFields resets all changes to the "include_sold_fields" field.
func (m *ItemTemplateMutation) ResetIncludeSoldFields() {
	m.include_sold_fields = nil
}

// SetDefaultTagIds sets the "default_tag_ids" field.
func (m *ItemTemplateMutation) SetDefaultTagIds(u []uuid.UUID) {
	m.default_tag_ids = &u
	m.appenddefault_tag_ids = nil
}

// DefaultTagIds returns the value of the "default_tag_ids" field in the mutation.
func (m *ItemTemplateMutation) DefaultTagIds() (r []uuid.UUID, exists bool) {
	v := m.default_tag_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTagIds returns the old "default_tag_ids" field's value of the ItemTemplate entity.
// If the ItemTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemTemplateMutation) OldDefaultTagIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTagIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTagIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTagIds: %w", err)
	}
	return oldValue.DefaultTagIds, nil
}

// AppendDefaultTagIds adds u to the "default_tag_ids" field.
func (m *ItemTemplateMutation) AppendDefaultTagIds(u []uuid.UUID) {
	m.appenddefault_tag_ids = append(m.appenddefault_tag_ids, u...)
}

// AppendedDefaultTagIds returns the list of values that were appended to the "default_tag_ids" field in this mutation.
func (m *ItemTemplateMutation) AppendedDefaultTagIds() ([]uuid.UUID, bool) {
	if len(m.appenddefault_tag_ids) == 0 {
		return nil, false
	}
	return m.appenddefault_tag_ids, true
}

// ClearDefaultTagIds clears the value of the "default_tag_ids" field.
func (m *ItemTemplateMutation) ClearDefaultTagIds() {
	m.default_tag_ids = nil
	m.appenddefault_tag_ids = nil
	m.clearedFields[itemtemplate.FieldDefaultTagIds] = struct{}{}
}

// DefaultTagIdsCleared returns if the "default_tag_ids" field was cleared in this mutation.
func (m *ItemTemplateMutation) DefaultTagIdsCleared() bool {
	_, ok := m.clearedFields[itemtemplate.FieldDefaultTagIds]
	return ok
}

// ResetDefaultTagIds resets all changes to the "default_tag_ids" field.
func (m *ItemTemplateMutation) ResetDefaultTagIds() {
	m.default_tag_ids = nil
	m.appenddefault_tag_ids = nil
	delete(m.clearedFields, itemtemplate.FieldDefaultTagIds)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *ItemTemplateMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *ItemTemplateMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *ItemTemplateMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *ItemTemplateMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *ItemTemplateMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *ItemTemplateMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddFieldIDs adds the "fields" edge to the TemplateField entity by ids.
func (m *ItemTemplateMutation) AddFieldIDs(ids ...uuid.UUID) {
	if m.fields == nil {
		m.fields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the TemplateField entity.
func (m *ItemTemplateMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the TemplateField entity was cleared.
func (m *ItemTemplateMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the TemplateField entity by IDs.
func (m *ItemTemplateMutation) RemoveFieldIDs(ids ...uuid.UUID) {
	if m.removedfields == nil {
		m.removedfields = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the TemplateField entity.
func (m *ItemTemplateMutation) RemovedFieldsIDs() (ids []uuid.UUID) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *ItemTemplateMutation) FieldsIDs() (ids []uuid.UUID) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *ItemTemplateMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// SetLocationID sets the "location" edge to the Entity entity by id.
func (m *ItemTemplateMutation) SetLocationID(id uuid.UUID) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Entity entity.
func (m *ItemTemplateMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Entity entity was cleared.
func (m *ItemTemplateMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ItemTemplateMutation) LocationID() (id uuid.UUID, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ItemTemplateMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ItemTemplateMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the ItemTemplateMutation builder.
func (m *ItemTemplateMutation) Where(ps ...predicate.ItemTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ItemTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ItemTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ItemTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ItemTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ItemTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ItemTemplate).
func (m *ItemTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemTemplateMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, itemtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, itemtemplate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, itemtemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, itemtemplate.FieldDescription)
	}
	if m.notes != nil {
		fields = append(fields, itemtemplate.FieldNotes)
	}
	if m.default_quantity != nil {
		fields = append(fields, itemtemplate.FieldDefaultQuantity)
	}
	if m.default_insured != nil {
		fields = append(fields, itemtemplate.FieldDefaultInsured)
	}
	if m.default_name != nil {
		fields = append(fields, itemtemplate.FieldDefaultName)
	}
	if m.default_description != nil {
		fields = append(fields, itemtemplate.FieldDefaultDescription)
	}
	if m.default_manufacturer != nil {
		fields = append(fields, itemtemplate.FieldDefaultManufacturer)
	}
	if m.default_model_number != nil {
		fields = append(fields, itemtemplate.FieldDefaultModelNumber)
	}
	if m.default_lifetime_warranty != nil {
		fields = append(fields, itemtemplate.FieldDefaultLifetimeWarranty)
	}
	if m.default_warranty_details != nil {
		fields = append(fields, itemtemplate.FieldDefaultWarrantyDetails)
	}
	if m.include_warranty_fields != nil {
		fields = append(fields, itemtemplate.FieldIncludeWarrantyFields)
	}
	if m.include_purchase_fields != nil {
		fields = append(fields, itemtemplate.FieldIncludePurchaseFields)
	}
	if m.include_sold_fields != nil {
		fields = append(fields, itemtemplate.FieldIncludeSoldFields)
	}
	if m.default_tag_ids != nil {
		fields = append(fields, itemtemplate.FieldDefaultTagIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itemtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case itemtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case itemtemplate.FieldName:
		return m.Name()
	case itemtemplate.FieldDescription:
		return m.Description()
	case itemtemplate.FieldNotes:
		return m.Notes()
	case itemtemplate.FieldDefaultQuantity:
		return m.DefaultQuantity()
	case itemtemplate.FieldDefaultInsured:
		return m.DefaultInsured()
	case itemtemplate.FieldDefaultName:
		return m.DefaultName()
	case itemtemplate.FieldDefaultDescription:
		return m.DefaultDescription()
	case itemtemplate.FieldDefaultManufacturer:
		return m.DefaultManufacturer()
	case itemtemplate.FieldDefaultModelNumber:
		return m.DefaultModelNumber()
	case itemtemplate.FieldDefaultLifetimeWarranty:
		return m.DefaultLifetimeWarranty()
	case itemtemplate.FieldDefaultWarrantyDetails:
		return m.DefaultWarrantyDetails()
	case itemtemplate.FieldIncludeWarrantyFields:
		return m.IncludeWarrantyFields()
	case itemtemplate.FieldIncludePurchaseFields:
		return m.IncludePurchaseFields()
	case itemtemplate.FieldIncludeSoldFields:
		return m.IncludeSoldFields()
	case itemtemplate.FieldDefaultTagIds:
		return m.DefaultTagIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itemtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case itemtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case itemtemplate.FieldName:
		return m.OldName(ctx)
	case itemtemplate.FieldDescription:
		return m.OldDescription(ctx)
	case itemtemplate.FieldNotes:
		return m.OldNotes(ctx)
	case itemtemplate.FieldDefaultQuantity:
		return m.OldDefaultQuantity(ctx)
	case itemtemplate.FieldDefaultInsured:
		return m.OldDefaultInsured(ctx)
	case itemtemplate.FieldDefaultName:
		return m.OldDefaultName(ctx)
	case itemtemplate.FieldDefaultDescription:
		return m.OldDefaultDescription(ctx)
	case itemtemplate.FieldDefaultManufacturer:
		return m.OldDefaultManufacturer(ctx)
	case itemtemplate.FieldDefaultModelNumber:
		return m.OldDefaultModelNumber(ctx)
	case itemtemplate.FieldDefaultLifetimeWarranty:
		return m.OldDefaultLifetimeWarranty(ctx)
	case itemtemplate.FieldDefaultWarrantyDetails:
		return m.OldDefaultWarrantyDetails(ctx)
	case itemtemplate.FieldIncludeWarrantyFields:
		return m.OldIncludeWarrantyFields(ctx)
	case itemtemplate.FieldIncludePurchaseFields:
		return m.OldIncludePurchaseFields(ctx)
	case itemtemplate.FieldIncludeSoldFields:
		return m.OldIncludeSoldFields(ctx)
	case itemtemplate.FieldDefaultTagIds:
		return m.OldDefaultTagIds(ctx)
	}
	return nil, fmt.Errorf("unknown ItemTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itemtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case itemtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case itemtemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case itemtemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case itemtemplate.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case itemtemplate.FieldDefaultQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultQuantity(v)
		return nil
	case itemtemplate.FieldDefaultInsured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultInsured(v)
		return nil
	case itemtemplate.FieldDefaultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultName(v)
		return nil
	case itemtemplate.FieldDefaultDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultDescription(v)
		return nil
	case itemtemplate.FieldDefaultManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultManufacturer(v)
		return nil
	case itemtemplate.FieldDefaultModelNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultModelNumber(v)
		return nil
	case itemtemplate.FieldDefaultLifetimeWarranty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultLifetimeWarranty(v)
		return nil
	case itemtemplate.FieldDefaultWarrantyDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultWarrantyDetails(v)
		return nil
	case itemtemplate.FieldIncludeWarrantyFields:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeWarrantyFields(v)
		return nil
	case itemtemplate.FieldIncludePurchaseFields:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludePurchaseFields(v)
		return nil
	case itemtemplate.FieldIncludeSoldFields:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeSoldFields(v)
		return nil
	case itemtemplate.FieldDefaultTagIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTagIds(v)
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemTemplateMutation) AddedFields() []string {
	var fields []string
	if m.adddefault_quantity != nil {
		fields = append(fields, itemtemplate.FieldDefaultQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case itemtemplate.FieldDefaultQuantity:
		return m.AddedDefaultQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case itemtemplate.FieldDefaultQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(itemtemplate.FieldDescription) {
		fields = append(fields, itemtemplate.FieldDescription)
	}
	if m.FieldCleared(itemtemplate.FieldNotes) {
		fields = append(fields, itemtemplate.FieldNotes)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultName) {
		fields = append(fields, itemtemplate.FieldDefaultName)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultDescription) {
		fields = append(fields, itemtemplate.FieldDefaultDescription)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultManufacturer) {
		fields = append(fields, itemtemplate.FieldDefaultManufacturer)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultModelNumber) {
		fields = append(fields, itemtemplate.FieldDefaultModelNumber)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultWarrantyDetails) {
		fields = append(fields, itemtemplate.FieldDefaultWarrantyDetails)
	}
	if m.FieldCleared(itemtemplate.FieldDefaultTagIds) {
		fields = append(fields, itemtemplate.FieldDefaultTagIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemTemplateMutation) ClearField(name string) error {
	switch name {
	case itemtemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case itemtemplate.FieldNotes:
		m.ClearNotes()
		return nil
	case itemtemplate.FieldDefaultName:
		m.ClearDefaultName()
		return nil
	case itemtemplate.FieldDefaultDescription:
		m.ClearDefaultDescription()
		return nil
	case itemtemplate.FieldDefaultManufacturer:
		m.ClearDefaultManufacturer()
		return nil
	case itemtemplate.FieldDefaultModelNumber:
		m.ClearDefaultModelNumber()
		return nil
	case itemtemplate.FieldDefaultWarrantyDetails:
		m.ClearDefaultWarrantyDetails()
		return nil
	case itemtemplate.FieldDefaultTagIds:
		m.ClearDefaultTagIds()
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemTemplateMutation) ResetField(name string) error {
	switch name {
	case itemtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case itemtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case itemtemplate.FieldName:
		m.ResetName()
		return nil
	case itemtemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case itemtemplate.FieldNotes:
		m.ResetNotes()
		return nil
	case itemtemplate.FieldDefaultQuantity:
		m.ResetDefaultQuantity()
		return nil
	case itemtemplate.FieldDefaultInsured:
		m.ResetDefaultInsured()
		return nil
	case itemtemplate.FieldDefaultName:
		m.ResetDefaultName()
		return nil
	case itemtemplate.FieldDefaultDescription:
		m.ResetDefaultDescription()
		return nil
	case itemtemplate.FieldDefaultManufacturer:
		m.ResetDefaultManufacturer()
		return nil
	case itemtemplate.FieldDefaultModelNumber:
		m.ResetDefaultModelNumber()
		return nil
	case itemtemplate.FieldDefaultLifetimeWarranty:
		m.ResetDefaultLifetimeWarranty()
		return nil
	case itemtemplate.FieldDefaultWarrantyDetails:
		m.ResetDefaultWarrantyDetails()
		return nil
	case itemtemplate.FieldIncludeWarrantyFields:
		m.ResetIncludeWarrantyFields()
		return nil
	case itemtemplate.FieldIncludePurchaseFields:
		m.ResetIncludePurchaseFields()
		return nil
	case itemtemplate.FieldIncludeSoldFields:
		m.ResetIncludeSoldFields()
		return nil
	case itemtemplate.FieldDefaultTagIds:
		m.ResetDefaultTagIds()
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.group != nil {
		edges = append(edges, itemtemplate.EdgeGroup)
	}
	if m.fields != nil {
		edges = append(edges, itemtemplate.EdgeFields)
	}
	if m.location != nil {
		edges = append(edges, itemtemplate.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itemtemplate.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case itemtemplate.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	case itemtemplate.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfields != nil {
		edges = append(edges, itemtemplate.EdgeFields)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case itemtemplate.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroup {
		edges = append(edges, itemtemplate.EdgeGroup)
	}
	if m.clearedfields {
		edges = append(edges, itemtemplate.EdgeFields)
	}
	if m.clearedlocation {
		edges = append(edges, itemtemplate.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case itemtemplate.EdgeGroup:
		return m.clearedgroup
	case itemtemplate.EdgeFields:
		return m.clearedfields
	case itemtemplate.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemTemplateMutation) ClearEdge(name string) error {
	switch name {
	case itemtemplate.EdgeGroup:
		m.ClearGroup()
		return nil
	case itemtemplate.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemTemplateMutation) ResetEdge(name string) error {
	switch name {
	case itemtemplate.EdgeGroup:
		m.ResetGroup()
		return nil
	case itemtemplate.EdgeFields:
		m.ResetFields()
		return nil
	case itemtemplate.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown ItemTemplate edge %s", name)
}

// MaintenanceEntryMutation represents an operation that mutates the MaintenanceEntry nodes in the graph.
type MaintenanceEntryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	date           *time.Time
	scheduled_date *time.Time
	name           *string
	description    *string
	cost           *float64
	addcost        *float64
	clearedFields  map[string]struct{}
	entity         *uuid.UUID
	clearedentity  bool
	done           bool
	oldValue       func(context.Context) (*MaintenanceEntry, error)
	predicates     []predicate.MaintenanceEntry
}

var _ ent.Mutation = (*MaintenanceEntryMutation)(nil)

// maintenanceentryOption allows management of the mutation configuration using functional options.
type maintenanceentryOption func(*MaintenanceEntryMutation)

// newMaintenanceEntryMutation creates new mutation for the MaintenanceEntry entity.
func newMaintenanceEntryMutation(c config, op Op, opts ...maintenanceentryOption) *MaintenanceEntryMutation {
	m := &MaintenanceEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeMaintenanceEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaintenanceEntryID sets the ID field of the mutation.
func withMaintenanceEntryID(id uuid.UUID) maintenanceentryOption {
	return func(m *MaintenanceEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *MaintenanceEntry
		)
		m.oldValue = func(ctx context.Context) (*MaintenanceEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MaintenanceEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaintenanceEntry sets the old MaintenanceEntry of the mutation.
func withMaintenanceEntry(node *MaintenanceEntry) maintenanceentryOption {
	return func(m *MaintenanceEntryMutation) {
		m.oldValue = func(context.Context) (*MaintenanceEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaintenanceEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaintenanceEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MaintenanceEntry entities.
func (m *MaintenanceEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MaintenanceEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MaintenanceEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MaintenanceEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MaintenanceEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MaintenanceEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MaintenanceEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MaintenanceEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MaintenanceEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MaintenanceEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEntityID sets the "entity_id" field.
func (m *MaintenanceEntryMutation) SetEntityID(u uuid.UUID) {
	m.entity = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *MaintenanceEntryMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.entity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldEntityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *MaintenanceEntryMutation) ResetEntityID() {
	m.entity = nil
}

// SetDate sets the "date" field.
func (m *MaintenanceEntryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *MaintenanceEntryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *MaintenanceEntryMutation) ClearDate() {
	m.date = nil
	m.clearedFields[maintenanceentry.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) DateCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *MaintenanceEntryMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, maintenanceentry.FieldDate)
}

// SetScheduledDate sets the "scheduled_date" field.
func (m *MaintenanceEntryMutation) SetScheduledDate(t time.Time) {
	m.scheduled_date = &t
}

// ScheduledDate returns the value of the "scheduled_date" field in the mutation.
func (m *MaintenanceEntryMutation) ScheduledDate() (r time.Time, exists bool) {
	v := m.scheduled_date
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledDate returns the old "scheduled_date" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldScheduledDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledDate: %w", err)
	}
	return oldValue.ScheduledDate, nil
}

// ClearScheduledDate clears the value of the "scheduled_date" field.
func (m *MaintenanceEntryMutation) ClearScheduledDate() {
	m.scheduled_date = nil
	m.clearedFields[maintenanceentry.FieldScheduledDate] = struct{}{}
}

// ScheduledDateCleared returns if the "scheduled_date" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) ScheduledDateCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldScheduledDate]
	return ok
}

// ResetScheduledDate resets all changes to the "scheduled_date" field.
func (m *MaintenanceEntryMutation) ResetScheduledDate() {
	m.scheduled_date = nil
	delete(m.clearedFields, maintenanceentry.FieldScheduledDate)
}

// SetName sets the "name" field.
func (m *MaintenanceEntryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MaintenanceEntryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MaintenanceEntryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MaintenanceEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MaintenanceEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MaintenanceEntryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[maintenanceentry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MaintenanceEntryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[maintenanceentry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MaintenanceEntryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, maintenanceentry.FieldDescription)
}

// SetCost sets the "cost" field.
func (m *MaintenanceEntryMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *MaintenanceEntryMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the MaintenanceEntry entity.
// If the MaintenanceEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceEntryMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *MaintenanceEntryMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *MaintenanceEntryMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *MaintenanceEntryMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *MaintenanceEntryMutation) ClearEntity() {
	m.clearedentity = true
	m.clearedFields[maintenanceentry.FieldEntityID] = struct{}{}
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *MaintenanceEntryMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *MaintenanceEntryMutation) EntityIDs() (ids []uuid.UUID) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *MaintenanceEntryMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// Where appends a list predicates to the MaintenanceEntryMutation builder.
func (m *MaintenanceEntryMutation) Where(ps ...predicate.MaintenanceEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MaintenanceEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MaintenanceEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MaintenanceEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MaintenanceEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MaintenanceEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MaintenanceEntry).
func (m *MaintenanceEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MaintenanceEntryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, maintenanceentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, maintenanceentry.FieldUpdatedAt)
	}
	if m.entity != nil {
		fields = append(fields, maintenanceentry.FieldEntityID)
	}
	if m.date != nil {
		fields = append(fields, maintenanceentry.FieldDate)
	}
	if m.scheduled_date != nil {
		fields = append(fields, maintenanceentry.FieldScheduledDate)
	}
	if m.name != nil {
		fields = append(fields, maintenanceentry.FieldName)
	}
	if m.description != nil {
		fields = append(fields, maintenanceentry.FieldDescription)
	}
	if m.cost != nil {
		fields = append(fields, maintenanceentry.FieldCost)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MaintenanceEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		return m.CreatedAt()
	case maintenanceentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case maintenanceentry.FieldEntityID:
		return m.EntityID()
	case maintenanceentry.FieldDate:
		return m.Date()
	case maintenanceentry.FieldScheduledDate:
		return m.ScheduledDate()
	case maintenanceentry.FieldName:
		return m.Name()
	case maintenanceentry.FieldDescription:
		return m.Description()
	case maintenanceentry.FieldCost:
		return m.Cost()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MaintenanceEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case maintenanceentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case maintenanceentry.FieldEntityID:
		return m.OldEntityID(ctx)
	case maintenanceentry.FieldDate:
		return m.OldDate(ctx)
	case maintenanceentry.FieldScheduledDate:
		return m.OldScheduledDate(ctx)
	case maintenanceentry.FieldName:
		return m.OldName(ctx)
	case maintenanceentry.FieldDescription:
		return m.OldDescription(ctx)
	case maintenanceentry.FieldCost:
		return m.OldCost(ctx)
	}
	return nil, fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case maintenanceentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case maintenanceentry.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case maintenanceentry.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case maintenanceentry.FieldScheduledDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledDate(v)
		return nil
	case maintenanceentry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case maintenanceentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case maintenanceentry.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MaintenanceEntryMutation) AddedFields() []string {
	var fields []string
	if m.addcost != nil {
		fields = append(fields, maintenanceentry.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MaintenanceEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case maintenanceentry.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case maintenanceentry.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MaintenanceEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(maintenanceentry.FieldDate) {
		fields = append(fields, maintenanceentry.FieldDate)
	}
	if m.FieldCleared(maintenanceentry.FieldScheduledDate) {
		fields = append(fields, maintenanceentry.FieldScheduledDate)
	}
	if m.FieldCleared(maintenanceentry.FieldDescription) {
		fields = append(fields, maintenanceentry.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MaintenanceEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaintenanceEntryMutation) ClearField(name string) error {
	switch name {
	case maintenanceentry.FieldDate:
		m.ClearDate()
		return nil
	case maintenanceentry.FieldScheduledDate:
		m.ClearScheduledDate()
		return nil
	case maintenanceentry.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MaintenanceEntryMutation) ResetField(name string) error {
	switch name {
	case maintenanceentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case maintenanceentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case maintenanceentry.FieldEntityID:
		m.ResetEntityID()
		return nil
	case maintenanceentry.FieldDate:
		m.ResetDate()
		return nil
	case maintenanceentry.FieldScheduledDate:
		m.ResetScheduledDate()
		return nil
	case maintenanceentry.FieldName:
		m.ResetName()
		return nil
	case maintenanceentry.FieldDescription:
		m.ResetDescription()
		return nil
	case maintenanceentry.FieldCost:
		m.ResetCost()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MaintenanceEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.entity != nil {
		edges = append(edges, maintenanceentry.EdgeEntity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MaintenanceEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maintenanceentry.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MaintenanceEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MaintenanceEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MaintenanceEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedentity {
		edges = append(edges, maintenanceentry.EdgeEntity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MaintenanceEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case maintenanceentry.EdgeEntity:
		return m.clearedentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MaintenanceEntryMutation) ClearEdge(name string) error {
	switch name {
	case maintenanceentry.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MaintenanceEntryMutation) ResetEdge(name string) error {
	switch name {
	case maintenanceentry.EdgeEntity:
		m.ResetEntity()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceEntry edge %s", name)
}

// NotifierMutation represents an operation that mutates the Notifier nodes in the graph.
type NotifierMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	url           *string
	is_active     *bool
	clearedFields map[string]struct{}
	group         *uuid.UUID
	clearedgroup  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Notifier, error)
	predicates    []predicate.Notifier
}

var _ ent.Mutation = (*NotifierMutation)(nil)

// notifierOption allows management of the mutation configuration using functional options.
type notifierOption func(*NotifierMutation)

// newNotifierMutation creates new mutation for the Notifier entity.
func newNotifierMutation(c config, op Op, opts ...notifierOption) *NotifierMutation {
	m := &NotifierMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifierID sets the ID field of the mutation.
func withNotifierID(id uuid.UUID) notifierOption {
	return func(m *NotifierMutation) {
		var (
			err   error
			once  sync.Once
			value *Notifier
		)
		m.oldValue = func(ctx context.Context) (*Notifier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifier sets the old Notifier of the mutation.
func withNotifier(node *Notifier) notifierOption {
	return func(m *NotifierMutation) {
		m.oldValue = func(context.Context) (*Notifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notifier entities.
func (m *NotifierMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifierMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifierMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notifier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *NotifierMutation) SetGroupID(u uuid.UUID) {
	m.group = &u
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *NotifierMutation) GroupID() (r uuid.UUID, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *NotifierMutation) ResetGroupID() {
	m.group = nil
}

// SetUserID sets the "user_id" field.
func (m *NotifierMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotifierMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotifierMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *NotifierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifierMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *NotifierMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *NotifierMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *NotifierMutation) ResetURL() {
	m.url = nil
}

// SetIsActive sets the "is_active" field.
func (m *NotifierMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *NotifierMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Notifier entity.
// If the Notifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifierMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *NotifierMutation) ResetIsActive() {
	m.is_active = nil
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *NotifierMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[notifier.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *NotifierMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *NotifierMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *NotifierMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotifierMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[notifier.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotifierMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotifierMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotifierMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotifierMutation builder.
func (m *NotifierMutation) Where(ps ...predicate.Notifier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notifier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notifier).
func (m *NotifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifierMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, notifier.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notifier.FieldUpdatedAt)
	}
	if m.group != nil {
		fields = append(fields, notifier.FieldGroupID)
	}
	if m.user != nil {
		fields = append(fields, notifier.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, notifier.FieldName)
	}
	if m.url != nil {
		fields = append(fields, notifier.FieldURL)
	}
	if m.is_active != nil {
		fields = append(fields, notifier.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifier.FieldCreatedAt:
		return m.CreatedAt()
	case notifier.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifier.FieldGroupID:
		return m.GroupID()
	case notifier.FieldUserID:
		return m.UserID()
	case notifier.FieldName:
		return m.Name()
	case notifier.FieldURL:
		return m.URL()
	case notifier.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notifier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifier.FieldGroupID:
		return m.OldGroupID(ctx)
	case notifier.FieldUserID:
		return m.OldUserID(ctx)
	case notifier.FieldName:
		return m.OldName(ctx)
	case notifier.FieldURL:
		return m.OldURL(ctx)
	case notifier.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Notifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notifier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifier.FieldGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case notifier.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notifier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifier.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case notifier.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Notifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifierMutation) ResetField(name string) error {
	switch name {
	case notifier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notifier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifier.FieldGroupID:
		m.ResetGroupID()
		return nil
	case notifier.FieldUserID:
		m.ResetUserID()
		return nil
	case notifier.FieldName:
		m.ResetName()
		return nil
	case notifier.FieldURL:
		m.ResetURL()
		return nil
	case notifier.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Notifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, notifier.EdgeGroup)
	}
	if m.user != nil {
		edges = append(edges, notifier.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifier.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case notifier.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifierMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, notifier.EdgeGroup)
	}
	if m.cleareduser {
		edges = append(edges, notifier.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifierMutation) EdgeCleared(name string) bool {
	switch name {
	case notifier.EdgeGroup:
		return m.clearedgroup
	case notifier.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifierMutation) ClearEdge(name string) error {
	switch name {
	case notifier.EdgeGroup:
		m.ClearGroup()
		return nil
	case notifier.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Notifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifierMutation) ResetEdge(name string) error {
	switch name {
	case notifier.EdgeGroup:
		m.ResetGroup()
		return nil
	case notifier.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Notifier edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	color           *string
	clearedFields   map[string]struct{}
	group           *uuid.UUID
	clearedgroup    bool
	entities        map[uuid.UUID]struct{}
	removedentities map[uuid.UUID]struct{}
	clearedentities bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *TagMutation) SetGroupID(id uuid.UUID) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *TagMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *TagMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *TagMutation) GroupID() (id uuid.UUID, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *TagMutation) GroupIDs() (ids []uuid.UUID) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *TagMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *TagMutation) AddEntityIDs(ids ...uuid.UUID) {
	if m.entities == nil {
		m.entities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *TagMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *TagMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *TagMutation) RemoveEntityIDs(ids ...uuid.UUID) {
	if m.removedentities == nil {
		m.removedentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *TagMutation) RemovedEntitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *TagMutation) EntitiesIDs() (ids []uuid.UUID) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *TagMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, tag.EdgeGroup)
	}
	if m.entities != nil {
		edges = append(edges, tag.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentities != nil {
		edges = append(edges, tag.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, tag.EdgeGroup)
	}
	if m.clearedentities {
		edges = append(edges, tag.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeGroup:
		return m.clearedgroup
	case tag.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeGroup:
		m.ResetGroup()
		return nil
	case tag.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TemplateFieldMutation represents an operation that mutates the TemplateField nodes in the graph.
type TemplateFieldMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	description          *string
	_type                *templatefield.Type
	text_value           *string
	clearedFields        map[string]struct{}
	item_template        *uuid.UUID
	cleareditem_template bool
	done                 bool
	oldValue             func(context.Context) (*TemplateField, error)
	predicates           []predicate.TemplateField
}

var _ ent.Mutation = (*TemplateFieldMutation)(nil)

// templatefieldOption allows management of the mutation configuration using functional options.
type templatefieldOption func(*TemplateFieldMutation)

// newTemplateFieldMutation creates new mutation for the TemplateField entity.
func newTemplateFieldMutation(c config, op Op, opts ...templatefieldOption) *TemplateFieldMutation {
	m := &TemplateFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateFieldID sets the ID field of the mutation.
func withTemplateFieldID(id uuid.UUID) templatefieldOption {
	return func(m *TemplateFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateField
		)
		m.oldValue = func(ctx context.Context) (*TemplateField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateField sets the old TemplateField of the mutation.
func withTemplateField(node *TemplateField) templatefieldOption {
	return func(m *TemplateFieldMutation) {
		m.oldValue = func(context.Context) (*TemplateField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateField entities.
func (m *TemplateFieldMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateFieldMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateFieldMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateFieldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateFieldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateFieldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateFieldMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateFieldMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateFieldMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TemplateFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateFieldMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TemplateFieldMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateFieldMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateFieldMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[templatefield.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateFieldMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[templatefield.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateFieldMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, templatefield.FieldDescription)
}

// SetType sets the "type" field.
func (m *TemplateFieldMutation) SetType(t templatefield.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TemplateFieldMutation) GetType() (r templatefield.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldType(ctx context.Context) (v templatefield.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TemplateFieldMutation) ResetType() {
	m._type = nil
}

// SetTextValue sets the "text_value" field.
func (m *TemplateFieldMutation) SetTextValue(s string) {
	m.text_value = &s
}

// TextValue returns the value of the "text_value" field in the mutation.
func (m *TemplateFieldMutation) TextValue() (r string, exists bool) {
	v := m.text_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTextValue returns the old "text_value" field's value of the TemplateField entity.
// If the TemplateField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateFieldMutation) OldTextValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextValue: %w", err)
	}
	return oldValue.TextValue, nil
}

// ClearTextValue clears the value of the "text_value" field.
func (m *TemplateFieldMutation) ClearTextValue() {
	m.text_value = nil
	m.clearedFields[templatefield.FieldTextValue] = struct{}{}
}

// TextValueCleared returns if the "text_value" field was cleared in this mutation.
func (m *TemplateFieldMutation) TextValueCleared() bool {
	_, ok := m.clearedFields[templatefield.FieldTextValue]
	return ok
}

// ResetTextValue resets all changes to the "text_value" field.
func (m *TemplateFieldMutation) ResetTextValue() {
	m.text_value = nil
	delete(m.clearedFields, templatefield.FieldTextValue)
}

// SetItemTemplateID sets the "item_template" edge to the ItemTemplate entity by id.
func (m *TemplateFieldMutation) SetItemTemplateID(id uuid.UUID) {
	m.item_template = &id
}

// ClearItemTemplate clears the "item_template" edge to the ItemTemplate entity.
func (m *TemplateFieldMutation) ClearItemTemplate() {
	m.cleareditem_template = true
}

// ItemTemplateCleared reports if the "item_template" edge to the ItemTemplate entity was cleared.
func (m *TemplateFieldMutation) ItemTemplateCleared() bool {
	return m.cleareditem_template
}

// ItemTemplateID returns the "item_template" edge ID in the mutation.
func (m *TemplateFieldMutation) ItemTemplateID() (id uuid.UUID, exists bool) {
	if m.item_template != nil {
		return *m.item_template, true
	}
	return
}

// ItemTemplateIDs returns the "item_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemTemplateID instead. It exists only for internal usage by the builders.
func (m *TemplateFieldMutation) ItemTemplateIDs() (ids []uuid.UUID) {
	if id := m.item_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItemTemplate resets all changes to the "item_template" edge.
func (m *TemplateFieldMutation) ResetItemTemplate() {
	m.item_template = nil
	m.cleareditem_template = false
}

// Where appends a list predicates to the TemplateFieldMutation builder.
func (m *TemplateFieldMutation) Where(ps ...predicate.TemplateField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateField).
func (m *TemplateFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateFieldMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, templatefield.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, templatefield.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, templatefield.FieldName)
	}
	if m.description != nil {
		fields = append(fields, templatefield.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, templatefield.FieldType)
	}
	if m.text_value != nil {
		fields = append(fields, templatefield.FieldTextValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templatefield.FieldCreatedAt:
		return m.CreatedAt()
	case templatefield.FieldUpdatedAt:
		return m.UpdatedAt()
	case templatefield.FieldName:
		return m.Name()
	case templatefield.FieldDescription:
		return m.Description()
	case templatefield.FieldType:
		return m.GetType()
	case templatefield.FieldTextValue:
		return m.TextValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templatefield.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case templatefield.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case templatefield.FieldName:
		return m.OldName(ctx)
	case templatefield.FieldDescription:
		return m.OldDescription(ctx)
	case templatefield.FieldType:
		return m.OldType(ctx)
	case templatefield.FieldTextValue:
		return m.OldTextValue(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templatefield.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case templatefield.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case templatefield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templatefield.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case templatefield.FieldType:
		v, ok := value.(templatefield.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case templatefield.FieldTextValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextValue(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateFieldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateFieldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templatefield.FieldDescription) {
		fields = append(fields, templatefield.FieldDescription)
	}
	if m.FieldCleared(templatefield.FieldTextValue) {
		fields = append(fields, templatefield.FieldTextValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateFieldMutation) ClearField(name string) error {
	switch name {
	case templatefield.FieldDescription:
		m.ClearDescription()
		return nil
	case templatefield.FieldTextValue:
		m.ClearTextValue()
		return nil
	}
	return fmt.Errorf("unknown TemplateField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateFieldMutation) ResetField(name string) error {
	switch name {
	case templatefield.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case templatefield.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case templatefield.FieldName:
		m.ResetName()
		return nil
	case templatefield.FieldDescription:
		m.ResetDescription()
		return nil
	case templatefield.FieldType:
		m.ResetType()
		return nil
	case templatefield.FieldTextValue:
		m.ResetTextValue()
		return nil
	}
	return fmt.Errorf("unknown TemplateField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item_template != nil {
		edges = append(edges, templatefield.EdgeItemTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case templatefield.EdgeItemTemplate:
		if id := m.item_template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateFieldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem_template {
		edges = append(edges, templatefield.EdgeItemTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case templatefield.EdgeItemTemplate:
		return m.cleareditem_template
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateFieldMutation) ClearEdge(name string) error {
	switch name {
	case templatefield.EdgeItemTemplate:
		m.ClearItemTemplate()
		return nil
	}
	return fmt.Errorf("unknown TemplateField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateFieldMutation) ResetEdge(name string) error {
	switch name {
	case templatefield.EdgeItemTemplate:
		m.ResetItemTemplate()
		return nil
	}
	return fmt.Errorf("unknown TemplateField edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	email              *string
	password           *string
	is_superuser       *bool
	superuser          *bool
	role               *user.Role
	activated_on       *time.Time
	oidc_issuer        *string
	oidc_subject       *string
	default_group_id   *uuid.UUID
	clearedFields      map[string]struct{}
	groups             map[uuid.UUID]struct{}
	removedgroups      map[uuid.UUID]struct{}
	clearedgroups      bool
	auth_tokens        map[uuid.UUID]struct{}
	removedauth_tokens map[uuid.UUID]struct{}
	clearedauth_tokens bool
	notifiers          map[uuid.UUID]struct{}
	removednotifiers   map[uuid.UUID]struct{}
	clearednotifiers   bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetIsSuperuser sets the "is_superuser" field.
func (m *UserMutation) SetIsSuperuser(b bool) {
	m.is_superuser = &b
}

// IsSuperuser returns the value of the "is_superuser" field in the mutation.
func (m *UserMutation) IsSuperuser() (r bool, exists bool) {
	v := m.is_superuser
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperuser returns the old "is_superuser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperuser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperuser: %w", err)
	}
	return oldValue.IsSuperuser, nil
}

// ResetIsSuperuser resets all changes to the "is_superuser" field.
func (m *UserMutation) ResetIsSuperuser() {
	m.is_superuser = nil
}

// SetSuperuser sets the "superuser" field.
func (m *UserMutation) SetSuperuser(b bool) {
	m.superuser = &b
}

// Superuser returns the value of the "superuser" field in the mutation.
func (m *UserMutation) Superuser() (r bool, exists bool) {
	v := m.superuser
	if v == nil {
		return
	}
	return *v, true
}

// OldSuperuser returns the old "superuser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSuperuser(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuperuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuperuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuperuser: %w", err)
	}
	return oldValue.Superuser, nil
}

// ResetSuperuser resets all changes to the "superuser" field.
func (m *UserMutation) ResetSuperuser() {
	m.superuser = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetActivatedOn sets the "activated_on" field.
func (m *UserMutation) SetActivatedOn(t time.Time) {
	m.activated_on = &t
}

// ActivatedOn returns the value of the "activated_on" field in the mutation.
func (m *UserMutation) ActivatedOn() (r time.Time, exists bool) {
	v := m.activated_on
	if v == nil {
		return
	}
	return *v, true
}

// OldActivatedOn returns the old "activated_on" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActivatedOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivatedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivatedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivatedOn: %w", err)
	}
	return oldValue.ActivatedOn, nil
}

// ClearActivatedOn clears the value of the "activated_on" field.
func (m *UserMutation) ClearActivatedOn() {
	m.activated_on = nil
	m.clearedFields[user.FieldActivatedOn] = struct{}{}
}

// ActivatedOnCleared returns if the "activated_on" field was cleared in this mutation.
func (m *UserMutation) ActivatedOnCleared() bool {
	_, ok := m.clearedFields[user.FieldActivatedOn]
	return ok
}

// ResetActivatedOn resets all changes to the "activated_on" field.
func (m *UserMutation) ResetActivatedOn() {
	m.activated_on = nil
	delete(m.clearedFields, user.FieldActivatedOn)
}

// SetOidcIssuer sets the "oidc_issuer" field.
func (m *UserMutation) SetOidcIssuer(s string) {
	m.oidc_issuer = &s
}

// OidcIssuer returns the value of the "oidc_issuer" field in the mutation.
func (m *UserMutation) OidcIssuer() (r string, exists bool) {
	v := m.oidc_issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldOidcIssuer returns the old "oidc_issuer" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOidcIssuer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOidcIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOidcIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOidcIssuer: %w", err)
	}
	return oldValue.OidcIssuer, nil
}

// ClearOidcIssuer clears the value of the "oidc_issuer" field.
func (m *UserMutation) ClearOidcIssuer() {
	m.oidc_issuer = nil
	m.clearedFields[user.FieldOidcIssuer] = struct{}{}
}

// OidcIssuerCleared returns if the "oidc_issuer" field was cleared in this mutation.
func (m *UserMutation) OidcIssuerCleared() bool {
	_, ok := m.clearedFields[user.FieldOidcIssuer]
	return ok
}

// ResetOidcIssuer resets all changes to the "oidc_issuer" field.
func (m *UserMutation) ResetOidcIssuer() {
	m.oidc_issuer = nil
	delete(m.clearedFields, user.FieldOidcIssuer)
}

// SetOidcSubject sets the "oidc_subject" field.
func (m *UserMutation) SetOidcSubject(s string) {
	m.oidc_subject = &s
}

// OidcSubject returns the value of the "oidc_subject" field in the mutation.
func (m *UserMutation) OidcSubject() (r string, exists bool) {
	v := m.oidc_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldOidcSubject returns the old "oidc_subject" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOidcSubject(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOidcSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOidcSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOidcSubject: %w", err)
	}
	return oldValue.OidcSubject, nil
}

// ClearOidcSubject clears the value of the "oidc_subject" field.
func (m *UserMutation) ClearOidcSubject() {
	m.oidc_subject = nil
	m.clearedFields[user.FieldOidcSubject] = struct{}{}
}

// OidcSubjectCleared returns if the "oidc_subject" field was cleared in this mutation.
func (m *UserMutation) OidcSubjectCleared() bool {
	_, ok := m.clearedFields[user.FieldOidcSubject]
	return ok
}

// ResetOidcSubject resets all changes to the "oidc_subject" field.
func (m *UserMutation) ResetOidcSubject() {
	m.oidc_subject = nil
	delete(m.clearedFields, user.FieldOidcSubject)
}

// SetDefaultGroupID sets the "default_group_id" field.
func (m *UserMutation) SetDefaultGroupID(u uuid.UUID) {
	m.default_group_id = &u
}

// DefaultGroupID returns the value of the "default_group_id" field in the mutation.
func (m *UserMutation) DefaultGroupID() (r uuid.UUID, exists bool) {
	v := m.default_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultGroupID returns the old "default_group_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDefaultGroupID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultGroupID: %w", err)
	}
	return oldValue.DefaultGroupID, nil
}

// ClearDefaultGroupID clears the value of the "default_group_id" field.
func (m *UserMutation) ClearDefaultGroupID() {
	m.default_group_id = nil
	m.clearedFields[user.FieldDefaultGroupID] = struct{}{}
}

// DefaultGroupIDCleared returns if the "default_group_id" field was cleared in this mutation.
func (m *UserMutation) DefaultGroupIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDefaultGroupID]
	return ok
}

// ResetDefaultGroupID resets all changes to the "default_group_id" field.
func (m *UserMutation) ResetDefaultGroupID() {
	m.default_group_id = nil
	delete(m.clearedFields, user.FieldDefaultGroupID)
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...uuid.UUID) {
	if m.groups == nil {
		m.groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...uuid.UUID) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []uuid.UUID) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddAuthTokenIDs adds the "auth_tokens" edge to the AuthTokens entity by ids.
func (m *UserMutation) AddAuthTokenIDs(ids ...uuid.UUID) {
	if m.auth_tokens == nil {
		m.auth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.auth_tokens[ids[i]] = struct{}{}
	}
}

// ClearAuthTokens clears the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) ClearAuthTokens() {
	m.clearedauth_tokens = true
}

// AuthTokensCleared reports if the "auth_tokens" edge to the AuthTokens entity was cleared.
func (m *UserMutation) AuthTokensCleared() bool {
	return m.clearedauth_tokens
}

// RemoveAuthTokenIDs removes the "auth_tokens" edge to the AuthTokens entity by IDs.
func (m *UserMutation) RemoveAuthTokenIDs(ids ...uuid.UUID) {
	if m.removedauth_tokens == nil {
		m.removedauth_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.auth_tokens, ids[i])
		m.removedauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAuthTokens returns the removed IDs of the "auth_tokens" edge to the AuthTokens entity.
func (m *UserMutation) RemovedAuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedauth_tokens {
		ids = append(ids, id)
	}
	return
}

// AuthTokensIDs returns the "auth_tokens" edge IDs in the mutation.
func (m *UserMutation) AuthTokensIDs() (ids []uuid.UUID) {
	for id := range m.auth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAuthTokens resets all changes to the "auth_tokens" edge.
func (m *UserMutation) ResetAuthTokens() {
	m.auth_tokens = nil
	m.clearedauth_tokens = false
	m.removedauth_tokens = nil
}

// AddNotifierIDs adds the "notifiers" edge to the Notifier entity by ids.
func (m *UserMutation) AddNotifierIDs(ids ...uuid.UUID) {
	if m.notifiers == nil {
		m.notifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifiers[ids[i]] = struct{}{}
	}
}

// ClearNotifiers clears the "notifiers" edge to the Notifier entity.
func (m *UserMutation) ClearNotifiers() {
	m.clearednotifiers = true
}

// NotifiersCleared reports if the "notifiers" edge to the Notifier entity was cleared.
func (m *UserMutation) NotifiersCleared() bool {
	return m.clearednotifiers
}

// RemoveNotifierIDs removes the "notifiers" edge to the Notifier entity by IDs.
func (m *UserMutation) RemoveNotifierIDs(ids ...uuid.UUID) {
	if m.removednotifiers == nil {
		m.removednotifiers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifiers, ids[i])
		m.removednotifiers[ids[i]] = struct{}{}
	}
}

// RemovedNotifiers returns the removed IDs of the "notifiers" edge to the Notifier entity.
func (m *UserMutation) RemovedNotifiersIDs() (ids []uuid.UUID) {
	for id := range m.removednotifiers {
		ids = append(ids, id)
	}
	return
}

// NotifiersIDs returns the "notifiers" edge IDs in the mutation.
func (m *UserMutation) NotifiersIDs() (ids []uuid.UUID) {
	for id := range m.notifiers {
		ids = append(ids, id)
	}
	return
}

// ResetNotifiers resets all changes to the "notifiers" edge.
func (m *UserMutation) ResetNotifiers() {
	m.notifiers = nil
	m.clearednotifiers = false
	m.removednotifiers = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_superuser != nil {
		fields = append(fields, user.FieldIsSuperuser)
	}
	if m.superuser != nil {
		fields = append(fields, user.FieldSuperuser)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.activated_on != nil {
		fields = append(fields, user.FieldActivatedOn)
	}
	if m.oidc_issuer != nil {
		fields = append(fields, user.FieldOidcIssuer)
	}
	if m.oidc_subject != nil {
		fields = append(fields, user.FieldOidcSubject)
	}
	if m.default_group_id != nil {
		fields = append(fields, user.FieldDefaultGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsSuperuser:
		return m.IsSuperuser()
	case user.FieldSuperuser:
		return m.Superuser()
	case user.FieldRole:
		return m.Role()
	case user.FieldActivatedOn:
		return m.ActivatedOn()
	case user.FieldOidcIssuer:
		return m.OidcIssuer()
	case user.FieldOidcSubject:
		return m.OidcSubject()
	case user.FieldDefaultGroupID:
		return m.DefaultGroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsSuperuser:
		return m.OldIsSuperuser(ctx)
	case user.FieldSuperuser:
		return m.OldSuperuser(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldActivatedOn:
		return m.OldActivatedOn(ctx)
	case user.FieldOidcIssuer:
		return m.OldOidcIssuer(ctx)
	case user.FieldOidcSubject:
		return m.OldOidcSubject(ctx)
	case user.FieldDefaultGroupID:
		return m.OldDefaultGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsSuperuser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperuser(v)
		return nil
	case user.FieldSuperuser:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuperuser(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldActivatedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivatedOn(v)
		return nil
	case user.FieldOidcIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOidcIssuer(v)
		return nil
	case user.FieldOidcSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOidcSubject(v)
		return nil
	case user.FieldDefaultGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldActivatedOn) {
		fields = append(fields, user.FieldActivatedOn)
	}
	if m.FieldCleared(user.FieldOidcIssuer) {
		fields = append(fields, user.FieldOidcIssuer)
	}
	if m.FieldCleared(user.FieldOidcSubject) {
		fields = append(fields, user.FieldOidcSubject)
	}
	if m.FieldCleared(user.FieldDefaultGroupID) {
		fields = append(fields, user.FieldDefaultGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldActivatedOn:
		m.ClearActivatedOn()
		return nil
	case user.FieldOidcIssuer:
		m.ClearOidcIssuer()
		return nil
	case user.FieldOidcSubject:
		m.ClearOidcSubject()
		return nil
	case user.FieldDefaultGroupID:
		m.ClearDefaultGroupID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsSuperuser:
		m.ResetIsSuperuser()
		return nil
	case user.FieldSuperuser:
		m.ResetSuperuser()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldActivatedOn:
		m.ResetActivatedOn()
		return nil
	case user.FieldOidcIssuer:
		m.ResetOidcIssuer()
		return nil
	case user.FieldOidcSubject:
		m.ResetOidcSubject()
		return nil
	case user.FieldDefaultGroupID:
		m.ResetDefaultGroupID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.auth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.notifiers != nil {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.auth_tokens))
		for id := range m.auth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.notifiers))
		for id := range m.notifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.removedauth_tokens != nil {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.removednotifiers != nil {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.removedauth_tokens))
		for id := range m.removedauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifiers:
		ids := make([]ent.Value, 0, len(m.removednotifiers))
		for id := range m.removednotifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.clearedauth_tokens {
		edges = append(edges, user.EdgeAuthTokens)
	}
	if m.clearednotifiers {
		edges = append(edges, user.EdgeNotifiers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeAuthTokens:
		return m.clearedauth_tokens
	case user.EdgeNotifiers:
		return m.clearednotifiers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeAuthTokens:
		m.ResetAuthTokens()
		return nil
	case user.EdgeNotifiers:
		m.ResetNotifiers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
