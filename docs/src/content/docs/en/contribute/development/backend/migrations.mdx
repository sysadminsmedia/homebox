---
title: Database Migrations
draft: true
---

import { FileTree } from '@astrojs/starlight/components';

Homebox supports two different database engines, and as such requires two different sets of migrations.

We make extensive use of [Goose](https://pressly.github.io/goose/documentation/annotations/)
for managing our database migrations. Goose supports both SQL-based migrations and Go-based migrations.

These migrations are located in the `backend/internal/data/migrations` directory. And there are two subdirectories for each database engine:
<FileTree>
    - backend
        - internal
            - data
                - migrations goose migrations (both required)
                    - postgres
                        - 20220929052825_init.sql
                        - 20241226183416_sync_children.go
                        - ...
                    - sqlite3
                        - 20220929052821_init.sql
                        - 20241226183418_sync_children.go
                        - ...
</FileTree>

## General Migration Best Practices
- Use the format `YYYYMMDDHHMMSS_description.ext` for naming your migration files.
- Always create migrations for both database engines, unless the change only applies to one. (e.g., fixing a bug that only affects Postgres)
- Test your migrations thoroughly to ensure they work as expected on both database engines.
- Migrations should never result in data loss. Data must always be migrated in a way that preserves existing data.
- Migrations should be unique globally across both database engine directories. (a limitation of Goose)
- Always use `INSERT INTO table SELECT column, column2, column3 ... FROM table2` statements to migrate data. Never use `INSERT INTO table SELECT * FROM table2`.
- We do not use "down" migrations, as all migrations are performed automatically, and are generally not reversible.

## Database Engines
### SQLite3
SQLite3 is a lightweight database engine included with Homebox as the default. Unfortunately, it's migrations can become rather
complicated due to lack of `ALTER TABLE` and `ALTER COLUMN` support. This results in a lot of boilerplate code for simple changes.

> [!IMPORTANT]
> When performing migrations on SQLite3, you will most likely have to perform a lot of `CREATE TABLE`, `DROP TABLE`, and `ALTER TABLE` statements.
> When working with parent tables (`groups`, `users`, etc.), you MUST perform a `PRAGMA foreign_keys = OFF` statement before performing any statements.
> You will also need `-- +goose no transaction` annotations immediate after the `-- +goose Up` annotation.
>
> Failure to disable foreign key constraints will result in the loss of data.


### Postgres
Postgres migrations are generally fairly straightforward. Currently we have no specific documentation for workarounds for Postgres-specific issues.

## SQL Migrations
SQL migrations make up the vast majority of our migrations. They are simple SQL files that contain SQL statements to be executed. With the appropraite
`-- +goose Up` annotations and any other required Goose annotations.

**Example SQL Migration:**
```sql title="20220929052825_example.sql"
-- +goose Up
SELECT * FROM users;
```

These SQL migrations are tracked by the "version" in Goose (the timestamp at the beginning of the filename) and are executed automatically when the server starts.
You should ensure that migrations are always run after any pre-existing migrations.

## Go Migrations
Go migrations are used to perform complex operations on the database. They are written in Go and are executed automatically by Goose when the server starts.

Go migrations give you significant flexibility over SQL migrations, but they are also generally more complex to write and maintain. We
recommend using SQL migrations whenever possible. Only use Go migrations when absolutely necessary.

**Example Go Migration:**
```go title="20220929052821_example.go"
package sqlite3

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/pressly/goose/v3"
)

//nolint:gochecknoinits
func init() {
	goose.AddMigrationContext(Up20220929052821, Down20220929052821)
}

func Up20220929052821(ctx context.Context, tx *sql.Tx) error {
	// Check if the 'sync_child_items_locations' column exists in the 'items' table
	columnName := "sync_child_items_locations"
	query := `
		SELECT name
		FROM pragma_table_info('items')
		WHERE name = 'sync_child_items_locations';
	`
	err := tx.QueryRowContext(ctx, query).Scan(&columnName)
	if err != nil {
		// Column does not exist, proceed with migration
		_, err = tx.ExecContext(ctx, `
			SELECT * FROM users;
		`)
		if err != nil {
			return fmt.Errorf("failed to execute migration: %w", err)
		}
	}
	return nil
}

func Down20220929052821(ctx context.Context, tx *sql.Tx) error {
	// This migration is a no-op for SQLite.
	return nil
}
```